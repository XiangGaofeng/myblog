<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NIO与Netty | Better Gaofeng</title><meta name="author" content="Better Gaofeng"><meta name="copyright" content="Better Gaofeng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NIO基础JavaSE中，我们了解了如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。 NIO框架是在J">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO与Netty">
<meta property="og:url" content="https://nicegaofeng.top/blog/b2896a54/index.html">
<meta property="og:site_name" content="Better Gaofeng">
<meta property="og:description" content="NIO基础JavaSE中，我们了解了如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。 NIO框架是在J">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png">
<meta property="article:published_time" content="2023-08-02T04:26:35.000Z">
<meta property="article:modified_time" content="2023-08-06T09:36:20.002Z">
<meta property="article:author" content="Better Gaofeng">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nicegaofeng.top/blog/b2896a54/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NIO与Netty',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-08-06 17:36:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/07/cRBHDM7K3xGgPWi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> GPT</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://gptweb.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTWEB</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academicgpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTACADEMIC</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://gpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTNEXT</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Better Gaofeng"><img class="site-icon" src="https://s2.loli.net/2023/06/30/BjFURc5Nud7k1gE.png"/><span class="site-name">Better Gaofeng</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> GPT</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://gptweb.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTWEB</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academicgpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTACADEMIC</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://gpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTNEXT</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NIO与Netty</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-02T04:26:35.000Z" title="发表于 2023-08-02 12:26:35">2023-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-06T09:36:20.002Z" title="更新于 2023-08-06 17:36:20">2023-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NIO/">NIO</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><p>JavaSE中，我们了解了如何使用IO进行数据传输，Java IO是阻塞的，如果在一次读写数据调用时数据还没有准备好，或者目前不可写，那么读写操作就会被阻塞直到数据准备好或目标可写为止。Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作。</p>
<p>NIO框架是在JDK1.4推出的，它的出现就是为了解决传统IO的不足。</p>
<h2 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h2><h3 id="Buffer类及其实现"><a href="#Buffer类及其实现" class="headerlink" title="Buffer类及其实现"></a>Buffer类及其实现</h3><p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。</p>
<p>Buffer是一个抽象类，它的核心内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="comment">// 这四个变量的关系: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">      <span class="comment">// 这些变量就是Buffer操作的核心了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接缓冲区实现子类的数据内存地址</span></span><br><span class="line">    <span class="type">long</span> address;</span><br></pre></td></tr></table></figure>

<p>我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了<code>boolean</code>类型之外）：</p>
<ul>
<li>IntBuffer - int类型的缓冲区。</li>
<li>ShortBuffer - short类型的缓冲区。</li>
<li>LongBuffer - long类型的缓冲区。</li>
<li>FloatBuffer - float类型的缓冲区。</li>
<li>DoubleBuffer - double类型的缓冲区。</li>
<li>ByteBuffer - byte类型的缓冲区。</li>
<li>CharBuffer - char类型的缓冲区。</li>
</ul>
<p>以IntBuffer为例，我们来看看如何创建一个Buffer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：</span></span><br><span class="line">    <span class="comment">//1. 申请一个容量为10的int缓冲区</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据）</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它的内部是本质上如何进行操作的呢？我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)   <span class="comment">//如果申请的容量小于0，那还有啥意思</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(capacity, capacity);   <span class="comment">//可以看到这里会直接创建一个新的IntBuffer实现类</span></span><br><span class="line">      <span class="comment">//HeapIntBuffer是在堆内存中存放数据，本质上就数组，一会我们可以在深入看一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//可以看到这个也是创建了一个新的HeapIntBuffer对象，并且给了初始数组以及截取的起始位置和长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IntBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);   <span class="comment">//调用的是上面的wrap方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBuffer又是如何实现的呢，我们接着来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HeapIntBuffer(<span class="type">int</span>[] buf, <span class="type">int</span> off, <span class="type">int</span> len) &#123; <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);   <span class="comment">//你会发现这怎么又去调父类的构造方法了，绕来绕去</span></span><br><span class="line">      <span class="comment">//mark是标记，off是当前起始下标位置，off+len是最大下标位置，buf.length是底层维护的数组真正长度，buf就是数组，最后一个0是起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们又来看看IntBuffer中的构造方法是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] hb;                  <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line"><span class="type">boolean</span> isReadOnly;                 <span class="comment">// 只有在堆缓冲区实现时才会使用</span></span><br><span class="line"></span><br><span class="line">IntBuffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap,   <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">             <span class="type">int</span>[] hb, <span class="type">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(mark, pos, lim, cap);  <span class="comment">//调用Buffer类的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.hb = hb;    <span class="comment">//hb就是真正我们要存放数据的数组，堆缓冲区底层其实就是这么一个数组</span></span><br><span class="line">    <span class="built_in">this</span>.offset = offset;   <span class="comment">//起始偏移位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看Buffer中的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer(<span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap) &#123;       <span class="comment">// 注意这个构造方法不是public，是默认的访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)  <span class="comment">//容量不能小于0，小于0还玩个锤子</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">    <span class="built_in">this</span>.capacity = cap;   <span class="comment">//设定缓冲区容量</span></span><br><span class="line">    limit(lim);    <span class="comment">//设定最大position位置</span></span><br><span class="line">    position(pos);   <span class="comment">//设定起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;  <span class="comment">//如果起始标记大于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; pos)  <span class="comment">//并且标记位置大于起始位置，那么就抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                               + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.mark = mark;   <span class="comment">//否则设定mark位置（mark默认为-1）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对源码的观察，我们大致可以得到以下结构了：</p>
<img src="https://s2.loli.net/2023/08/02/XyHmEPFCV1oKcka.png" alt="image-20230802145454947" style="zoom:50%;" />

<p>现在我们来总结一下上面这些结构的各自职责划分：</p>
<ul>
<li>Buffer：缓冲区的一些基本变量定义，比如当前的位置（position）、容量 (capacity)、最大限制 (limit)、标记 (mark)等，你肯定会疑惑这些变量有啥用，别着急，这些变量会在后面的操作中用到，我们逐步讲解。</li>
<li>IntBuffer等子类：定义了存放数据的数组（只有堆缓冲区实现子类才会用到）、是否只读等，也就是说数据的存放位置、以及对于底层数组的相关操作都在这里已经定义好了，并且已经实现了Comparable接口。</li>
<li>HeapIntBuffer堆缓冲区实现子类：数据存放在堆中，实际上就是用的父类的数组在保存数据，并且将父类定义的所有底层操作全部实现了。</li>
</ul>
<h3 id="缓冲区写操作"><a href="#缓冲区写操作" class="headerlink" title="缓冲区写操作"></a>缓冲区写操作</h3><p>前面我们了解了Buffer类的基本操作，现在我们来看一下如何向缓冲区中存放数据以及获取数据，数据的存放包括以下四个方法：</p>
<ul>
<li>public abstract IntBuffer put(int i);   -   在当前position位置插入数据，由具体子类实现</li>
<li>public abstract IntBuffer put(int index, int i);   -   在指定位置存放数据，也是由具体子类实现</li>
<li>public final IntBuffer put(int[] src);   -   直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</li>
<li>public IntBuffer put(int[] src, int offset, int length);   -   直接存放数组中的内容，同上，但是可以指定存放一段范围</li>
<li>public IntBuffer put(IntBuffer src);   -   直接存放另一个缓冲区中的内容</li>
</ul>
<h4 id="IntBuffer-put-int-i"><a href="#IntBuffer-put-int-i" class="headerlink" title="IntBuffer put(int i)"></a>IntBuffer put(int i)</h4><p>我们从最简单的开始看，是在当前位置插入一个数据，那么这个当前位置是怎么定义的呢，我们来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;   <span class="comment">//这个ix和nextPutIndex()很灵性，我们来看看具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">ix</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextPutIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> position;    <span class="comment">//获取Buffer类中的position位置（一开始也是0）</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= limit)    <span class="comment">//位置肯定不能超过底层数组最大长度，否则越界</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    position = p + <span class="number">1</span>;   <span class="comment">//获取之后会使得Buffer类中的position+1</span></span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//返回当前的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以put操作实际上是将底层数组<code>hb</code>在position位置上的数据进行设定。</p>
<p><img src="https://s2.loli.net/2023/03/06/krusLfxyGnDHWFw.png" alt="image-20230306172609624"></p>
<p>设定完成后，position自动后移：</p>
<p><img src="https://s2.loli.net/2023/03/06/6hrs4Spq1bnvXWa.png" alt="image-20230306172619452"></p>
<h4 id="IntBuffer-put-int-i-int-x"><a href="#IntBuffer-put-int-i-int-x" class="headerlink" title="IntBuffer put(int i, int x)"></a>IntBuffer put(int i, int x)</h4><p>接着我们来看看第二个put操作是如何进行，它能够在指定位置插入数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;  <span class="comment">//这里依然会使用ix，但是会检查位置是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">checkIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;                       <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))    <span class="comment">//插入的位置不能小于0并且不能大于等于底层数组最大长度</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">//没有问题就把i返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个比我们之前的要好理解一些，注意全程不会操作position的值，这里需要注意一下。</p>
<h4 id="IntBuffer-put-int-src-int-offset-int-length"><a href="#IntBuffer-put-int-src-int-offset-int-length" class="headerlink" title="IntBuffer put(int[] src, int offset, int length)"></a>IntBuffer put(int[] src, int offset, int length)</h4><p>我们接着来看第三个put操作，它是直接在IntBuffer中实现的，是基于前两个put方法的子类实现来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    checkBounds(offset, length, src.length);   <span class="comment">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//接着判断要插入的数据量在缓冲区是否容得下，装不下也不行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset + length;   <span class="comment">//计算出最终读取位置，下面开始for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; end; i++)</span><br><span class="line">        <span class="built_in">this</span>.put(src[i]);   <span class="comment">//注意是直接从postion位置开始插入，直到指定范围结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//ojbk</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);   <span class="comment">//因为不需要指定范围，所以直接0和length，然后调上面的，多捞哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">remaining</span><span class="params">()</span> &#123;  <span class="comment">//计算并获取当前缓冲区的剩余空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> limit - position;   <span class="comment">//最大容量减去当前位置，就是剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> rem &gt; <span class="number">0</span> ? rem : <span class="number">0</span>;  <span class="comment">//没容量就返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkBounds</span><span class="params">(<span class="type">int</span> off, <span class="type">int</span> len, <span class="type">int</span> size)</span> &#123; <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">  	<span class="comment">//实际上就是看给定的数组能不能截取出指定的这段数据，如果都不够了那肯定不行啊</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>大致流程如下，首先来了一个数组要取一段数据全部丢进缓冲区：</p>
<img src="https://s2.loli.net/2023/03/06/hxzUm6Xgd1ABcTi.png" alt="image-20230306172652962" style="zoom: 33%;" />

<p>在检查没有什么问题并且缓冲区有容量时，就可以开始插入了：</p>
<img src="https://s2.loli.net/2023/03/06/WLrnhBpyG5uxC24.png" alt="image-20230306172704570" style="zoom:33%;" />

<p>最后我们通过代码来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    buffer.put(arr, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">//从下标3开始，截取4个元素</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));  <span class="comment">//array方法可以直接获取到数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后结果为：</p>
<p><img src="https://s2.loli.net/2023/03/06/Ke59YxvBjJnNhzb.png" alt="image-20230306172716044"></p>
<h4 id="IntBuffer-put-IntBuffer-src"><a href="#IntBuffer-put-IntBuffer-src" class="headerlink" title="IntBuffer put(IntBuffer src)"></a>IntBuffer put(IntBuffer src)</h4><p>当然我们也可以将一个缓冲区的内容保存到另一个缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (src == <span class="built_in">this</span>)<span class="comment">//不会吧不会吧，不会有人保存自己吧</span></span><br><span class="line">          <span class="keyword">throw</span> createSameBufferException();</span><br><span class="line">      <span class="keyword">if</span> (isReadOnly())<span class="comment">//如果是只读的话，那么也是不允许插入操作的,为啥就这里会判断只读</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">srcPos</span> <span class="operator">=</span> src.position(); <span class="comment">//src的position位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">srcLim</span> <span class="operator">=</span> src.limit();<span class="comment">//src的limit位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">srcRem</span> <span class="operator">=</span> (srcPos &lt;= srcLim ? srcLim - srcPos : <span class="number">0</span>);<span class="comment">//让我看看你有多少内容需要写</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> position();<span class="comment">//target的position位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> limit();</span><br><span class="line">      <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);<span class="comment">//看看target有多少位置可以写</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (srcRem &gt; rem)<span class="comment">//写不下的话</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferOverflowException</span>();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">srcBase</span> <span class="operator">=</span> src.base();<span class="comment">//这是src的hb</span></span><br><span class="line">      <span class="keyword">assert</span> srcBase != <span class="literal">null</span> || src.isDirect();<span class="comment">//src的hb不为空或者你是直接内存创建的，</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">base</span> <span class="operator">=</span> base();<span class="comment">//target的hb</span></span><br><span class="line">          <span class="keyword">assert</span> base != <span class="literal">null</span> || isDirect(); <span class="comment">//同理</span></span><br><span class="line"></span><br><span class="line">          <span class="type">long</span> <span class="variable">srcAddr</span> <span class="operator">=</span> src.address + ((<span class="type">long</span>)srcPos &lt;&lt; <span class="number">2</span>);<span class="comment">//src在缓冲区中的实际地址</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> address + ((<span class="type">long</span>)pos &lt;&lt; <span class="number">2</span>);<span class="comment">//target在缓冲区中的实际地址</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">long</span>)srcRem &lt;&lt; <span class="number">2</span>;<span class="comment">//需要写入的两倍</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">//开始复制，代码省略</span></span><br><span class="line">          position(pos + srcRem); <span class="comment">// 设置target的position索引</span></span><br><span class="line">          src.position(srcPos + srcRem);<span class="comment">// 设置src的position索引</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>为什么这个put方法需要判断只读</li>
</ol>
<ul>
<li>在Java中，<code>IntBuffer</code>有两种类型：可读写（read-write）和只读（read-only）。可读写缓冲区允许读取和写入操作，而只读缓冲区只允许读取操作。</li>
<li><code>put(int i)</code>方法是用于向可读写缓冲区写入数据的方法，因此不需要进行只读检查。如果当前缓冲区是只读缓冲区，那么在创建该缓冲区实例时已经限制了写入操作，所以不需要在这个方法中再次进行判断。</li>
<li>相反，<code>put(IntBuffer src)</code>方法涉及到从一个缓冲区复制数据到另一个缓冲区，因此需要确保目标缓冲区是可写的。因此，在<code>put(IntBuffer src)</code>方法中需要判断目标缓冲区是否为只读缓冲区，以避免对只读缓冲区进行写入操作。</li>
</ul>
<ol start="2">
<li>isDirect()</li>
</ol>
<ul>
<li>用于判断当前缓冲区是否是直接缓冲区（direct buffer）的方法。直接缓冲区是一种通过调用<code>ByteBuffer.allocateDirect()</code>方法创建的缓冲区，它的数据存储在堆外内存中。</li>
<li>获取一个<code>ByteBuffer</code>对象，可以通过调用<code>ByteBuffer.allocateDirect()</code>方法来创建一个直接缓冲区的字节缓冲区。</li>
<li>将字节缓冲区转换为<code>IntBuffer</code>对象，可以通过调用<code>ByteBuffer.asIntBuffer()</code>方法来实现。</li>
</ul>
</blockquote>
<p>我们来看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<p>但是如果是这样的话，会出现问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);   <span class="comment">//手动插入数据</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(src);</span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<p>们发现，结果和上面的不一样，并没有成功地将数据填到下面的IntBuffer中，这是为什么呢？实际上就是因为<code>position</code>的计算问题，由于我们在写操作(<code>put()</code>)完成之后，position跑到后面去了</p>
<p>所以我们得想个办法把position给退回到一开始的位置，这样才可以从头开始读取，那么怎么做呢？一般我们在写入完成后需要进行读操作时（后面都是这样，不只是这里），会使用<code>flip()</code>方法进行翻转：</p>
<p>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position;    <span class="comment">//修改limit值，当前写到哪里，下次读的最终位置就是这里，limit的作用开始慢慢体现了</span></span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//position归零</span></span><br><span class="line">    mark = -<span class="number">1</span>;    <span class="comment">//标记还原为-1，但是现在我们还没用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IntBuffer</span> <span class="variable">src</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) src.put(i);</span><br><span class="line">        src.flip() ;<span class="comment">//手动插入数据</span></span><br><span class="line">        <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put(src);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<h3 id="缓冲区读操作"><a href="#缓冲区读操作" class="headerlink" title="缓冲区读操作"></a>缓冲区读操作</h3><p>读操作有四个方法：</p>
<ul>
<li><code>public abstract int get();</code>    -    直接获取当前position位置的数据，由子类实现</li>
<li><code>public abstract int get(int index); </code>  -    获取指定位置的数据，也是子类实现</li>
<li><code>public IntBuffer get(int[] dst)</code>  -   将数据读取到给定的数组中</li>
<li><code>public IntBuffer get(int[] dst, int offset, int length)</code>  -   同上，加了个范围</li>
</ul>
<h4 id="int-get"><a href="#int-get" class="headerlink" title="int get()"></a>int get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];    <span class="comment">//直接从数组中取就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nextGetIndex</span><span class="params">()</span> &#123;                          <span class="comment">// 好家伙，这不跟前面那个一模一样吗</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> position;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= limit)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferUnderflowException</span>();</span><br><span class="line">  position = p + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到每次读取操作之后，也会将postion+1，直到最后一个位置，如果还要继续读，那么就直接抛出异常。</p>
<p><img src="https://s2.loli.net/2023/03/06/OPGBJYS9ajzd2mI.png"></p>
<h4 id="get-int-dst-和get-int-dst-int-offset-int-length"><a href="#get-int-dst-和get-int-dst-int-offset-int-length" class="headerlink" title="get(int[] dst)和get(int[] dst, int offset, int length)"></a>get(int[] dst)和get(int[] dst, int offset, int length)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">get</span><span class="params">(<span class="type">int</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);   <span class="comment">//跟put操作一样，也是需要检查是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())   <span class="comment">//如果读取的长度比可以读的长度大，那肯定是不行的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferUnderflowException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> offset + length;    <span class="comment">//计算出最终读取位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();   <span class="comment">//开始从position把数据读到数组中，注意是在数组的offset位置开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(int[] dst)调用的是get(int[] dst, int offset, int length)</p>
<h3 id="缓冲区其他操作"><a href="#缓冲区其他操作" class="headerlink" title="缓冲区其他操作"></a>缓冲区其他操作</h3><ul>
<li><code>public abstract IntBuffer compact()</code>   -   压缩缓冲区，由具体实现类实现</li>
<li><code>public IntBuffer duplicate()</code>   -   复制缓冲区，会直接创建一个新的数据相同的缓冲区</li>
<li><code>public abstract IntBuffer slice()</code>   -    划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作</li>
<li><code>public final Buffer rewind()</code>  -   重置缓冲区，其实就是把position归零，然后mark变回-1</li>
<li><code>public final Buffer clear()</code>  -   将缓冲区清空，所有的变量变回最初的状态</li>
</ul>
<h4 id="压缩缓冲区-compact"><a href="#压缩缓冲区-compact" class="headerlink" title="压缩缓冲区 compact()"></a>压缩缓冲区 compact()</h4><p>会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">compact</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> position();   <span class="comment">//获取当前位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> limit();    <span class="comment">//获取当前最大position位置</span></span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);   <span class="comment">//断言表达式，position必须小于最大位置，肯定的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);  <span class="comment">//计算pos距离最大位置的长度</span></span><br><span class="line">    System.arraycopy(hb, ix(pos), hb, ix(<span class="number">0</span>), rem);   <span class="comment">//直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间</span></span><br><span class="line">    position(rem);   <span class="comment">//直接将position移动到rem位置</span></span><br><span class="line">    limit(capacity());   <span class="comment">//pos最大位置修改为最大容量</span></span><br><span class="line">    discardMark();   <span class="comment">//mark变回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如现在的状态是：</p>
<p><img src="https://s2.loli.net/2023/03/06/ljJbiNLHY26q3rE.png" alt="image-20230306172820209"></p>
<p>那么我们在执行<code> compact()</code>方法之后，会进行截取，此时<code>limit - position = 6</code>，那么就会截取第<code>4、5、6、7、8、9</code>这6个数据然后丢到最前面，接着position跑到<code>7</code>表示这是下一个继续的位置：</p>
<p><img src="https://s2.loli.net/2023/03/06/9bJ1uamBelMV5Qt.png" alt="image-20230306172828232"></p>
<p>现在我们通过代码来检验一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();   <span class="comment">//先正常读4个</span></span><br><span class="line">    buffer.compact();   <span class="comment">//压缩缓冲区</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;压缩之后的情况：&quot;</span>+Arrays.toString(buffer.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+buffer.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+buffer.limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后的结果没有问题：</p>
<p><img src="https://s2.loli.net/2023/03/06/wBxO3SPFZpYjXMV.png" alt="image-20230306172840891"></p>
<h4 id="复制缓冲区-duplicate"><a href="#复制缓冲区-duplicate" class="headerlink" title="复制缓冲区 duplicate()"></a>复制缓冲区 duplicate()</h4><p>如果我们现在需要复制一个内容一模一样的的缓冲区，该怎么做？直接使用<code>duplicate()</code>方法就可以复制了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">duplicate</span><span class="params">()</span> &#123;   <span class="comment">//直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(hb,</span><br><span class="line">                                    <span class="built_in">this</span>.markValue(),</span><br><span class="line">                                    <span class="built_in">this</span>.position(),</span><br><span class="line">                                    <span class="built_in">this</span>.limit(),</span><br><span class="line">                                    <span class="built_in">this</span>.capacity(),</span><br><span class="line">                                    offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么各位猜想一下，如果通过这种方式创了一个新的IntBuffer，那么下面的例子会出现什么结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">duplicate</span> <span class="operator">=</span> buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    System.out.println(buffer == duplicate);</span><br><span class="line">    System.out.println(buffer.array() == duplicate.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于buffer是重新new的，所以第一个为false，而底层的数组由于在构造的时候没有进行任何的拷贝而是直接传递，因此实际上两个缓冲区的底层数组是同一个对象。所以，一个发生修改，那么另一个就跟着变了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">duplicate</span> <span class="operator">=</span> buffer.duplicate();</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="number">0</span>, <span class="number">66666</span>);</span><br><span class="line">    System.out.println(duplicate.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="划分缓冲区-slice"><a href="#划分缓冲区-slice" class="headerlink" title="划分缓冲区 slice()"></a>划分缓冲区 slice()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">slice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="built_in">this</span>.position();   <span class="comment">//获取当前position</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> <span class="built_in">this</span>.limit();     <span class="comment">//获取position最大位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);   <span class="comment">//求得剩余空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBuffer</span>(hb,    <span class="comment">//返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个</span></span><br><span class="line">                                    -<span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>,</span><br><span class="line">                                    rem,    <span class="comment">//新的容量变成了剩余空间的大小</span></span><br><span class="line">                                    rem,</span><br><span class="line">                                    pos + offset);   <span class="comment">//可以看到offset的地址不再是0了，而是当前的position加上原有的offset值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然现在底层依然使用的是之前的数组，但是由于设定了offset值，我们之前的操作似乎变得不太一样了：</p>
<p><img src="https://s2.loli.net/2023/03/06/PBdcqUj4sCpwn1m.png" alt="image-20230306172901061"></p>
<p>回顾前面我们所讲解的内容，在读取和存放时，会被<code>ix</code>方法进行调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">ix</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;   <span class="comment">//现在offset为4，那么也就是说逻辑上的i是0但是得到真实位置却是4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];   <span class="comment">//最后会经过ix方法转换为真正在数组中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，在逻辑上我们可以认为是这样的：</p>
<p><img src="https://s2.loli.net/2023/03/06/ic9zoQgfnOxuwSR.png" alt="image-20230306172911560"></p>
<p>现在我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) buffer.get();</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.slice();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的情况：&quot;</span>+Arrays.toString(slice.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;划分之后的偏移地址：&quot;</span>+slice.arrayOffset());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前position位置：&quot;</span>+slice.position());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前limit位置：&quot;</span>+slice.limit());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slice.hasRemaining()) &#123;   <span class="comment">//将所有的数据全部挨着打印出来</span></span><br><span class="line">        System.out.print(slice.get()+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终结果：</p>
<p><img src="https://s2.loli.net/2023/03/06/fC7I81wAGVngNlu.png" alt="image-20230306172926439"></p>
<h4 id="重置缓冲区-rewind"><a href="#重置缓冲区-rewind" class="headerlink" title="重置缓冲区 rewind()"></a>重置缓冲区 rewind()</h4><p>它相当于是对position和mark进行了一次重置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清空缓冲区-rewind"><a href="#清空缓冲区-rewind" class="headerlink" title="清空缓冲区 rewind()"></a>清空缓冲区 rewind()</h4><p>它相当于是将整个缓冲区回归到最初的状态了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    position = <span class="number">0</span>;    <span class="comment">//同上</span></span><br><span class="line">    limit = capacity;   <span class="comment">//limit变回capacity</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h3><p>缓冲区之间是可以进行比较的，我们可以看到equals方法和compareTo方法都是被重写了的，我们首先来看看<code>equals</code>方法，注意，它是判断两个缓冲区剩余的内容是否一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object ob)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == ob)   <span class="comment">//要是两个缓冲区是同一个对象，肯定一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> IntBuffer))  <span class="comment">//类型不是IntBuffer那也不用比了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">that</span> <span class="operator">=</span> (IntBuffer)ob;   <span class="comment">//转换为IntBuffer</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">thisPos</span> <span class="operator">=</span> <span class="built_in">this</span>.position();  <span class="comment">//获取当前缓冲区的相关信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">thisLim</span> <span class="operator">=</span> <span class="built_in">this</span>.limit();</span><br><span class="line">    <span class="type">int</span> <span class="variable">thatPos</span> <span class="operator">=</span> that.position();  <span class="comment">//获取另一个缓冲区的相关信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">thatLim</span> <span class="operator">=</span> that.limit();</span><br><span class="line">    <span class="type">int</span> <span class="variable">thisRem</span> <span class="operator">=</span> thisLim - thisPos; </span><br><span class="line">    <span class="type">int</span> <span class="variable">thatRem</span> <span class="operator">=</span> thatLim - thatPos;</span><br><span class="line">    <span class="keyword">if</span> (thisRem &lt; <span class="number">0</span> || thisRem != thatRem)   <span class="comment">//如果剩余容量小于0或是两个缓冲区的剩余容量不一样，也不行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  	<span class="comment">//注意比较的是剩余的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> thisLim - <span class="number">1</span>, j = thatLim - <span class="number">1</span>; i &gt;= thisPos; i--, j--)  <span class="comment">//从最后一个开始倒着往回比剩余的区域</span></span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="built_in">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//只要发现不一样的就不用继续了，直接false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//上面的比较都没问题，那么就true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x == y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们按照它的思路来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//直接比较</span></span><br><span class="line">    </span><br><span class="line">    buffer1.position(<span class="number">6</span>);</span><br><span class="line">    buffer2.position(<span class="number">6</span>);</span><br><span class="line">    System.out.println(buffer1.equals(buffer2));   <span class="comment">//比较从下标6开始的剩余内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果就是我们所想的那样：</p>
<p><img src="https://s2.loli.net/2023/03/06/Nf4WRSpQZUrHXj7.png" alt="image-20230306172945627"></p>
<p>那么我们接着来看比较，<code>compareTo</code>方法，它实际上是<code>Comparable</code>接口提供的方法，它实际上比较的也是pos开始剩余的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(IntBuffer that)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">thisPos</span> <span class="operator">=</span> <span class="built_in">this</span>.position();    <span class="comment">//获取并计算两个缓冲区的pos和remain</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">thisRem</span> <span class="operator">=</span> <span class="built_in">this</span>.limit() - thisPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">thatPos</span> <span class="operator">=</span> that.position();</span><br><span class="line">    <span class="type">int</span> <span class="variable">thatRem</span> <span class="operator">=</span> that.limit() - thatPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.min(thisRem, thatRem);   <span class="comment">//选取一个剩余空间最小的出来</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>)   <span class="comment">//如果最小的小于0，那就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> thisPos + Math.min(thisRem, thatRem);  <span class="comment">//计算n的值当前的pos加上剩余的最小空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> thisPos, j = thatPos; i &lt; n; i++, j++) &#123;  <span class="comment">//从两个缓冲区的当前位置开始，一直到n结束</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> compare(<span class="built_in">this</span>.get(i), that.get(j));  <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;   <span class="comment">//只要出现不相同的，那么就返回比较出来的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thisRem - thatRem; <span class="comment">//如果没比出来个所以然，那么就比长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IntBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">IntBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">//测试compareto方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;buffer1.compareTo(buffer2) = &quot;</span> + buffer1.compareTo(buffer2));</span><br><span class="line">        </span><br><span class="line">        buffer1.position(<span class="number">6</span>);</span><br><span class="line">        buffer2.position(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;buffer1.compareTo(buffer2) = &quot;</span> + buffer1.compareTo(buffer2));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//buffer1.compareTo(buffer2) = -1</span></span><br><span class="line"><span class="comment">//buffer1.compareTo(buffer2) = 0</span></span><br></pre></td></tr></table></figure>

<h3 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h3><p>接着我们来看看只读缓冲区，只读缓冲区就像其名称一样，它只能进行读操作，而不允许进行写操作。</p>
<p>那么我们怎么创建只读缓冲区呢？</p>
<ul>
<li><code>public abstract IntBuffer asReadOnlyBuffer();</code>   -   基于当前缓冲区生成一个只读的缓冲区。</li>
</ul>
<p>我们来看看此方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">asReadOnlyBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeapIntBufferR</span>(hb,    <span class="comment">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组</span></span><br><span class="line">                                 <span class="built_in">this</span>.markValue(),</span><br><span class="line">                                 <span class="built_in">this</span>.position(),</span><br><span class="line">                                 <span class="built_in">this</span>.limit(),</span><br><span class="line">                                 <span class="built_in">this</span>.capacity(),</span><br><span class="line">                                 offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个HeapIntBufferR类跟我们普通的HeapIntBuffer有什么不同之处呢？</p>
<p><img src="https://s2.loli.net/2023/03/06/4XiVxHTbApPmkMK.png" alt="image-20230306173005107"></p>
<p>可以看到它是继承自HeapIntBuffer的，那么我们来看看它的实现有什么不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">HeapIntBufferR</span><span class="params">(<span class="type">int</span>[] buf,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> mark, <span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> cap,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(buf, mark, pos, lim, cap, off);</span><br><span class="line">    <span class="built_in">this</span>.isReadOnly = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在其构造方法中，除了直接调用父类的构造方法外，还会将<code>isReadOnly</code>标记修改为true，我们接着来看put操作有什么不同之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IntBuffer <span class="title function_">put</span><span class="params">(IntBuffer src)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReadOnlyBufferException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有的put方法全部凉凉，只要调用就会直接抛出ReadOnlyBufferException异常。但是其他get方法依然没有进行重写，也就是说get操作还是可以正常使用的，但是只要是写操作就都不行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.wrap(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    System.out.println(readBuffer.isReadOnly());</span><br><span class="line">    System.out.println(readBuffer.get());</span><br><span class="line">    readBuffer.put(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteBuffer和CharBuffer"><a href="#ByteBuffer和CharBuffer" class="headerlink" title="ByteBuffer和CharBuffer"></a>ByteBuffer和CharBuffer</h3><p>现在我们来看看另外两种基本类型的缓冲区ByteBuffer和CharBuffer，因为ByteBuffer底层存放的是很多单个byte字节，所以会有更多的玩法，同样CharBuffer是一系列字节，所以也有很多便捷操作。</p>
<p>我们先来看看ByteBuffer，我们可以直接点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ByteBuffer</span> <span class="keyword">extends</span> <span class="title class_">Buffer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">boolean</span> isReadOnly;                 <span class="comment">// Valid only for heap buffers</span></span><br><span class="line">  	....</span><br></pre></td></tr></table></figure>

<p>可以看到如果也是使用堆缓冲区子类实现，那么依然是一个<code>byte[]</code>的形式保存数据。我们来尝试使用一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//除了直接丢byte进去之外，我们也可以丢其他的基本类型（注意容量消耗）</span></span><br><span class="line">    buffer.putInt(Integer.MAX_VALUE);  <span class="comment">//丢个int的最大值进去，注意一个int占4字节</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前缓冲区剩余字节数：&quot;</span>+buffer.remaining());  <span class="comment">//只剩6个字节了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们来尝试读取一下，记得先翻转</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println(buffer.get());   <span class="comment">//一共四个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果为：</p>
<p><img src="https://s2.loli.net/2023/03/06/16zaudJ9WvGybsE.png" alt="image-20230306173044493"></p>
<p>可以看到第一个byte为127、然后三个都是-1，我们来分析一下：</p>
<ul>
<li><code>127</code> 转换为二进制补码形式就是 <code>01111111</code>，而<code>-1</code>转换为二进制补码形式为<code>11111111</code></li>
</ul>
<p>那也就是说，第一个字节是01111111，而后续字节就是11111111，把它们拼接在一起：</p>
<ul>
<li>二进制补码表示<code>01111111 11111111 11111111 11111111</code> 转换为十进制就是<code>2147483647</code>，也就是int的最大值。</li>
</ul>
<p>那么根据我们上面的推导，各位能否计算得到下面的结果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put((<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    buffer.put((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">    buffer.put((<span class="type">byte</span>) -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    buffer.flip();   <span class="comment">//翻转一下</span></span><br><span class="line">    System.out.println(buffer.getInt());  <span class="comment">//以int形式获取，那么就是一次性获取4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的计算，得到的结果就是：</p>
<ul>
<li>上面的数据以二进制补码的形式表示为：<code>00000000 00000000 00000001 11111111</code></li>
<li>将其转换为十进制那么就是：256 + 255 &#x3D; 511</li>
</ul>
<p>我们接着来看看CharBuffer，这种缓冲区实际上也是保存一大堆char类型的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);  <span class="comment">//除了可以直接丢char之外，字符串也可以一次性丢进入</span></span><br><span class="line">    System.out.println(Arrays.toString(buffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是正是得益于char数组，它包含了很多的字符串操作，可以一次性存放一整个字符串。我们甚至还可以将其当做一个String来进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buffer.put(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    buffer.append(<span class="string">&quot;!&quot;</span>);   <span class="comment">//可以像StringBuilder一样使用append来继续添加数据</span></span><br><span class="line">  </span><br><span class="line">  	System.out.println(<span class="string">&quot;剩余容量：&quot;</span>+buffer.remaining());  <span class="comment">//已经用了6个字符了</span></span><br><span class="line"></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;整个字符串为：&quot;</span>+buffer);   <span class="comment">//直接将内容转换为字符串</span></span><br><span class="line">    System.out.println(<span class="string">&quot;第3个字符是：&quot;</span>+buffer.charAt(<span class="number">2</span>));  <span class="comment">//直接像String一样charAt</span></span><br><span class="line"></span><br><span class="line">    buffer   <span class="comment">//也可以转换为IntStream进行操作</span></span><br><span class="line">            .chars()</span><br><span class="line">            .filter(i -&gt; i &lt; <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">            .forEach(i -&gt; System.out.print((<span class="type">char</span>) i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然除了一些常规操作之外，我们还可以直接将一个字符串作为参数创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//可以直接使用wrap包装一个字符串，但是注意，包装出来之后是只读的</span></span><br><span class="line">    <span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> CharBuffer.wrap(<span class="string">&quot;收藏等于学会~&quot;</span>);</span><br><span class="line">    System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="string">&quot;111&quot;</span>);  <span class="comment">//这里尝试进行一下写操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到结果也是我们预料中的：</p>
<p><img src="https://s2.loli.net/2023/03/06/yBxj2DrCcYAuWdH.png" alt="image-20230306173059478"></p>
<h2 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h2><p>在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。</p>
<h3 id="通道接口层次"><a href="#通道接口层次" class="headerlink" title="通道接口层次"></a>通道接口层次</h3><p>通道的根基接口是<code>Channel</code>，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//通道是否处于开启状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为通道开启也需要关闭，所以实现了Closeable接口，所以这个方法懂的都懂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看它的一些子接口，首先是最基本的读写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    <span class="comment">//将通道中的数据读取到给定的缓冲区中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  	<span class="comment">//将给定缓冲区中的数据写入到通道中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了读写功能后，最后整合为了一个ByteChannel接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ByteChannel</span> <span class="keyword">extends</span> <span class="title class_">ReadableByteChannel</span>, WritableByteChannel&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/Db75mNEcI2xgwM8.png" alt="image-20230306173149309"></p>
<p>在ByteChannel之下，还有更多的派生接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许保留position和更改position的通道，以及对通道连接实体的相关操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SeekableByteChannel</span> <span class="keyword">extends</span> <span class="title class_">ByteChannel</span> &#123;</span><br><span class="line">   	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的position</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">position</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改当前的position</span></span><br><span class="line">    SeekableByteChannel <span class="title function_">position</span><span class="params">(<span class="type">long</span> newPosition)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此通道连接到的实体（比如文件）的当前大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此通道连接到的实体截断（比如文件，截断之后，文件后面一半就没了）为给定大小</span></span><br><span class="line">    SeekableByteChannel <span class="title function_">truncate</span><span class="params">(<span class="type">long</span> size)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来看，除了读写之外，Channel还可以具有响应中断的能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterruptibleChannel</span> <span class="keyword">extends</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">  	<span class="comment">//当其他线程调用此方法时，在此通道上处于阻塞状态的线程会直接抛出 AsynchronousCloseException 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是InterruptibleChannel的抽象实现，完成了一部分功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title class_">Channel</span>, InterruptibleChannel &#123;</span><br><span class="line">		<span class="comment">//加锁关闭操作用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">closeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  	<span class="comment">//当前Channel的开启状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">open</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractInterruptibleChannel</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭操作实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (closeLock) &#123;   <span class="comment">//同时只能有一个线程进行此操作，加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!open)   <span class="comment">//如果已经关闭了，那么就不用继续了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            open = <span class="literal">false</span>;   <span class="comment">//开启状态变成false</span></span><br><span class="line">            implCloseChannel();   <span class="comment">//开始关闭通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法由 close 方法调用，以执行关闭通道的具体操作，仅当通道尚未关闭时才调用此方法，不会多次调用。</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">implCloseChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始阻塞（有可能一直阻塞下去）操作之前，需要调用此方法进行标记，</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//阻塞操作结束之后，也需要需要调用此方法，为了防止异常情况导致此方法没有被调用，建议放在finally中</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">(<span class="type">boolean</span> completed)</span></span><br><span class="line">				...</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而之后的一些实现类，都是基于这些接口定义的方法去进行实现的，比如FileChannel：</p>
<p><img src="https://s2.loli.net/2023/03/06/ZywX8BgGMJfWNSK.png" alt="image-20230306173207144"></p>
<p>这样，我们就大致了解了一下通道相关的接口定义，那么我来看看具体是如何如何使用的。</p>
<p>比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  	<span class="comment">//数组创建好，一会用来存放从流中读取到的数据</span></span><br><span class="line">  	<span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">  	<span class="comment">//直接使用输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> System.in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(data)) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//将输入流中的数据一次性读取到数组中</span></span><br><span class="line">            System.out.print(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));  <span class="comment">//读取了多少打印多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在我们使用通道之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  	<span class="comment">//缓冲区创建好，一会就靠它来传输数据</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据</span></span><br><span class="line">    <span class="type">ReadableByteChannel</span> <span class="variable">readChannel</span> <span class="operator">=</span> Channels.newChannel(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//将通道中的数据写到缓冲区中，缓冲区最多一次装10个</span></span><br><span class="line">        readChannel.read(buffer);</span><br><span class="line">        <span class="comment">//写入操作结束之后，需要进行翻转，以便接下来的读取操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">//最后转换成String打印出来康康</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取到一批数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        <span class="comment">//回到最开始的状态</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。</p>
<h3 id="文件传输FileChannel"><a href="#文件传输FileChannel" class="headerlink" title="文件传输FileChannel"></a>文件传输FileChannel</h3><p>我们来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>;</span><br><span class="line">        out.write(data.getBytes());   <span class="comment">//向文件的输出流中写入数据，也就是把数据写到文件中</span></span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[in.available()];</span><br><span class="line">        in.read(bytes);    <span class="comment">//从文件的输入流中读取文件的信息</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> in.getChannel();</span><br><span class="line">    <span class="comment">//创建一个容量为128的缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过输入流获取的文件通道读取是没有任何问题的，但是写入操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取操作</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> in.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/UVQ8gIpHyGrveMO.png" alt="image-20230306173252329"></p>
<p>直接报错，说明只支持读取操作，那么输出流呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持写入操作</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> out.getChannel();</span><br><span class="line">    <span class="comment">//尝试写入一下</span></span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到能够正常进行写入，但是读取呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1. 直接通过输入或输出流获取对应的通道</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//但是这里的通道只支持读取或是写入操作</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> out.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//从通道中将数据读取到缓冲区中</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    <span class="comment">//翻转一下，接下来要读取了</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/isrDoy5pwRPxMuK.png" alt="image-20230306173302648"></p>
<p>可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：</p>
<p>我们通过<code>RandomAccessFile</code>来创建通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来测试一下它的读写操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      通过RandomAccessFile进行创建，注意后面的mode有几种：</span></span><br><span class="line"><span class="comment">      r        以只读的方式使用</span></span><br><span class="line"><span class="comment">      rw   读操作和写操作都可以</span></span><br><span class="line"><span class="comment">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据</span></span><br><span class="line"><span class="comment">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  <span class="comment">//这里设定为支持读写，这样创建的通道才能具有这些功能</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel())&#123;   <span class="comment">//通过RandomAccessFile创建一个通道</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(<span class="string">&quot;伞兵二号马飞飞准备就绪！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成之后文件访问位置：&quot;</span>+channel.position());  <span class="comment">//注意读取也是从现在的位置开始</span></span><br><span class="line">        channel.position(<span class="number">0</span>);  <span class="comment">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个FileChannel既可以完成文件读取，也可以完成文件的写入。</p>
<p>除了基本的读写操作，我们也可以直接对文件进行截断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel())&#123;</span><br><span class="line">        <span class="comment">//截断文件，只留前20个字节</span></span><br><span class="line">        channel.truncate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件的内容直接被截断了，文件内容就只剩一半了。这里说的是test.txt的内容被截断</p>
<p>当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        inChannel.transferTo(<span class="number">0</span>, inChannel.size(), out.getChannel());   <span class="comment">//直接将test文件通道中的数据转到test2文件的通道中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，反向操作也是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test2.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> in.getChannel();   <span class="comment">//获取到test文件的通道</span></span><br><span class="line">        out.getChannel().transferFrom(inChannel, <span class="number">0</span>, inChannel.size());   <span class="comment">//直接将从test文件通道中传来的数据转给test2文件的通道</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意一定要是可写的，不然无法进行修改操作</span></span><br><span class="line"><span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过map方法映射文件的某一段内容，创建MappedByteBuffer对象</span></span><br><span class="line">    <span class="comment">//比如这里就是从第四个字节开始，映射10字节内容到内存中</span></span><br><span class="line">  	<span class="comment">//注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件</span></span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容</span></span><br><span class="line">  	<span class="comment">//注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写</span></span><br><span class="line">  	<span class="comment">//注意我们只映射了10个字节，也就是写的内容不能超出10字节了</span></span><br><span class="line">    buffer.put(<span class="string">&quot;yyds&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编辑完成后，通过force方法将数据写回文件的映射区域</span></span><br><span class="line">    buffer.force();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。</p>
<h3 id="文件锁FileLock"><a href="#文件锁FileLock" class="headerlink" title="文件锁FileLock"></a>文件锁FileLock</h3><p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<p>那么我们来看看如何使用文件锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">  	<span class="comment">//创建RandomAccessFile对象，并拿到Channel</span></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> f.getChannel();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 正在尝试获取文件锁...&quot;</span>);</span><br><span class="line">  	<span class="comment">//接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里）</span></span><br><span class="line">  	<span class="comment">//加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁</span></span><br><span class="line">  	<span class="comment">//范围锁甚至可以提前加到一个还未写入的位置上</span></span><br><span class="line">    <span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.lock(<span class="number">0</span>, <span class="number">6</span>, <span class="literal">false</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 已获取到文件锁！&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);   <span class="comment">//假设要处理5秒钟</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; 操作完毕，释放文件锁！&quot;</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//操作完成之后使用release方法进行锁释放</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关共享锁和独占锁：</p>
<ul>
<li>进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。</li>
<li>进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。</li>
</ul>
<h2 id="多路复用网络通信"><a href="#多路复用网络通信" class="headerlink" title="多路复用网络通信"></a>多路复用网络通信</h2><h3 id="传统阻塞I-x2F-O网络通信"><a href="#传统阻塞I-x2F-O网络通信" class="headerlink" title="传统阻塞I&#x2F;O网络通信"></a>传统阻塞I&#x2F;O网络通信</h3><p>说起网络通信，在JavaWeb阶段，我们使用Socket建立TCP连接进行网络通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>))&#123;    <span class="comment">//将服务端创建在端口8080上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在等待客户端连接...&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));  <span class="comment">//通过</span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>);</span><br><span class="line">        System.out.println(reader.readLine());</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream());</span><br><span class="line">        writer.write(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(stream);  <span class="comment">//通过转换流来帮助我们快速写入内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        writer.write(text+<span class="string">&#x27;\n&#x27;</span>);   <span class="comment">//因为对方是readLine()这里加个换行符</span></span><br><span class="line">        writer.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已发送：&quot;</span>+text);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+reader.readLine());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端连接失败！&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端断开连接！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使用前面的通道来进行通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新的ServerSocketChannel，一会直接使用SocketChannel进行网络IO操作</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open())&#123;</span><br><span class="line">        <span class="comment">//依然是将其绑定到8080端口</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//同样是调用accept()方法，阻塞等待新的连接到来</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">        <span class="comment">//因为是通道，两端的信息都是可以明确的，这里获取远端地址，当然也可以获取本地地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用缓冲区进行数据接收</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        socket.read(buffer);   <span class="comment">//SocketChannel同时实现了读写通道接口，所以可以直接进行双向操作</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.print(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">        socket.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得关</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">        channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">        channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然可以通过传统的Socket进行网络通信，但是我们发现，如果要进行IO操作，我们需要单独创建一个线程来进行处理，比如现在有很多个客户端，服务端需要同时进行处理，那么如果我们要处理这些客户端的请求，那么我们就只能单独为其创建一个线程来进行处理：</p>
<p><img src="https://s2.loli.net/2023/03/06/FOrzfHUKTNonJvt.png" alt="image-20230306173456889"></p>
<p>虽然这样看起来比较合理，但是随着客户端数量的增加，如果要保持持续通信，那么就不能摧毁这些线程，而是需要一直保留（但是实际上很多时候只是保持连接，一直在阻塞等待客户端的读写操作，IO操作的频率很低，这样就白白占用了一条线程，很多时候都是站着茅坑不拉屎），但是我们的线程不可能无限制的进行创建，总有一天会耗尽服务端的资源，那么现在怎么办呢，关键是现在又有很多客户端源源不断地连接并进行操作，这时，我们就可以利用NIO为我们提供的多路复用编程模型。</p>
<p>我们来看看NIO为我们提供的模型：</p>
<p><img src="https://s2.loli.net/2023/03/06/jFS86QyLHAwn9fR.png" alt="image-20230306173506227"></p>
<p>服务端不再是一个单纯通过<code>accept()</code>方法来创建连接的机制了，而是根据客户端不同的状态，Selector会不断轮询，只有客户端在对应的状态时，比如真正开始读写操作时，才会创建线程或进行处理（这样就不会一直阻塞等待某个客户端的IO操作了），而不是创建之后需要一直保持连接，即使没有任何的读写操作。这样就不会因为占着茅坑不拉屎导致线程无限制地创建下去了。</p>
<p>通过这种方式，甚至单线程都能做到高效的复用，最典型的例子就是Redis了，因为内存的速度非常快，多线程上下文的开销就会显得有些拖后腿，还不如直接单线程简单高效，这也是为什么Redis单线程也能这么快的原因。</p>
<h3 id="选择器与I-x2F-O多路复用"><a href="#选择器与I-x2F-O多路复用" class="headerlink" title="选择器与I&#x2F;O多路复用"></a>选择器与I&#x2F;O多路复用</h3><p>前面我们大概了解了一下选择器，我们知道，选择器是当具体有某一个状态（比如读、写、请求）已经就绪时，才会进行处理，而不是让我们的程序主动地进行等待。</p>
<p>既然我们现在需要实现IO多路复用，那么我们来看看常见的IO多路复用模型，也就是Selector的实现方案，比如现在有很多个用户连接到我们的服务器：</p>
<ul>
<li><strong>select</strong>：当这些连接出现具体的某个状态时，只是知道已经就绪了，但是不知道详具体是哪一个连接已经就绪，每次调用都进行线性遍历所有连接，时间复杂度为<code>O(n)</code>，并且存在最大连接数限制。</li>
<li><strong>poll</strong>：同上，但是由于底层采用链表，所以没有最大连接数限制。</li>
<li><strong>epoll</strong>：采用事件通知方式，当某个连接就绪，能够直接进行精准通知（这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的，只要就绪会会直接回调callback函数，实现精准通知，但是只有Linux支持这种方式），时间复杂度<code>O(1)</code>，Java在Linux环境下正是采用的这种模式进行实现的。</li>
</ul>
<ol>
<li>Select 模型：Select 模型是最早引入的 I&#x2F;O 多路复用模型之一。它使用 <code>select</code> 函数来监听多个 I&#x2F;O 事件，一般是通过一个文件描述符集合来管理需要监听的文件描述符。当有 I&#x2F;O 事件发生时，<code>select</code> 函数会返回，然后程序可以通过遍历文件描述符集合来确定具体是哪些文件描述符发生了事件。</li>
<li>Poll 模型：Poll 模型是对 Select 模型的改进。它使用 <code>poll</code> 函数来监听多个 I&#x2F;O 事件，与 Select 模型相比，Poll 模型不再需要维护文件描述符集合，而是通过一个 <code>pollfd</code> 结构数组来管理需要监听的文件描述符以及相应的事件。当有 I&#x2F;O 事件发生时，<code>poll</code> 函数会返回，然后程序可以遍历 <code>pollfd</code> 数组来确定具体是哪些文件描述符发生了事件。</li>
<li>Epoll 模型：Epoll 模型是在 Linux 系统上引入的高性能 I&#x2F;O 多路复用模型。它使用 <code>epoll</code> 函数来监听多个 I&#x2F;O 事件，与 Select 和 Poll 模型相比，Epoll 模型在处理大量并发连接时具有更好的性能。Epoll 模型使用一个事件表来管理需要监听的文件描述符，并通过 <code>epoll_ctl</code> 函数来注册和删除事件。当有 I&#x2F;O 事件发生时，程序可以通过调用 <code>epoll_wait</code> 函数来获取具体的事件信息。</li>
<li>Kqueue 模型：Kqueue 模型是在 BSD 系统上引入的高性能 I&#x2F;O 多路复用模型。它使用 <code>kqueue</code> 函数来监听多个 I&#x2F;O 事件，类似于 Epoll 模型，Kqueue 模型也使用一个事件表来管理需要监听的文件描述符，并通过 <code>kevent</code> 结构来描述事件。Kqueue 模型可以同时监听多种类型的事件，包括读、写、错误等，具有较高的灵活性和性能。</li>
</ol>
<p>我们来看看如何让我们的网络通信实现多路复用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">         <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open())&#123;   <span class="comment">//开启一个新的Selector，这玩意也是要关闭释放资源的</span></span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//要使用选择器进行操作，必须使用非阻塞的方式，这样才不会像阻塞IO那样卡在accept()，而是直接通过，让选择器去进行下一步操作</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将选择器注册到ServerSocketChannel中，后面是选择需要监听的时间，只有发生对应事件时才会进行选择，多个事件用 | 连接，注意，并不是所有的Channel都支持以下全部四个事件，可能只支持部分</span></span><br><span class="line">        <span class="comment">//因为是ServerSocketChannel这里我们就监听accept就可以了，等待客户端连接</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_CONNECT --- 连接就绪事件，表示客户端与服务器的连接已经建立成功</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_ACCEPT --- 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_READ --- 读 就绪事件，表示通道中已经有了可读的数据，可以执行读操作了</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_WRITE --- 写 就绪事件，表示已经可以向通道写数据了（这玩意比较特殊，一般情况下因为都是可以写入的，所以可能会无限循环）</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//无限循环等待新的用户网络操作</span></span><br><span class="line">            <span class="comment">//每次选择都可能会选出多个已经就绪的网络操作，没有操作时会暂时阻塞</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//根据不同的事件类型，执行不同的操作即可</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;  <span class="comment">//如果当前ServerSocketChannel已经做好准备处理Accept</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">                    <span class="comment">//现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</span></span><br><span class="line">                    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">//这样就在连接建立时完成了注册</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;    <span class="comment">//如果当前连接有可读的数据并且可以写，那么就开始处理</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//直接向通道中写入数据就行</span></span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                    <span class="comment">//别关，说不定用户还要继续通信呢</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完成后，一定记得移出迭代器，不然下次还有</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们来编写一下客户客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新的SocketChannel，一会通过通道进行通信</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务端！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;   <span class="comment">//咱给它套个无限循环，这样就能一直发消息了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">//直接向通道中写入数据，真舒服</span></span><br><span class="line">            channel.write(ByteBuffer.wrap(text.getBytes()));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送！&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);   <span class="comment">//直接从通道中读取数据</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务器返回：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果：</p>
<p><img src="https://s2.loli.net/2023/03/06/NM3AosF5fYcJmCe.png" alt="image-20230306173522171"></p>
<p><img src="https://s2.loli.net/2023/03/06/Skr5gyIlzojnPGf.png" alt="image-20230306173532269"></p>
<h3 id="实现Reactor模式"><a href="#实现Reactor模式" class="headerlink" title="实现Reactor模式"></a>实现Reactor模式</h3><p>前面我们简单实现了多路复用网络通信，我们接着来了解一下Reactor模式，对我们的服务端进行优化。</p>
<p>现在我们来看看如何进行优化，我们首先抽象出两个组件，Reactor线程和Handler处理器：</p>
<ul>
<li>Reactor线程：负责响应IO事件，并分发到Handler处理器。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Handler处理器：执行非阻塞的操作。</li>
</ul>
<p>实际上我们之前编写的算是一种单线程Reactor的朴素模型（面向过程的写法），我们来看看标准的写法：</p>
<p><img src="https://s2.loli.net/2023/03/06/IFmc73Bb9ihwE8V.png" alt="image-20230306173542506"></p>
<p>客户端还是按照我们上面的方式连接到Reactor，并通过选择器走到Acceptor或是Handler，Acceptor主要负责客户端连接的建立，Handler负责读写操作，代码如下，首先是Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是Acceptor，实际上就是把上面的业务代码搬个位置罢了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acceptor主要用于处理连接操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel, Selector selector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//这里在注册时，创建好对应的Handler，这样在Reactor中分发的时候就可以直接调用Handler了</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> <span class="title class_">Handler</span>(channel));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在注册时丢了一个附加对象进去，这个附加对象会在选择器选择到此通道上时，可以通过<code>attachment()</code>方法进行获取，对于我们简化代码有大作用，一会展示，我们接着来看看Reactor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Runnable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//注册时，将Acceptor作为附加对象存放，当选择器选择后也可以获取到</span></span><br><span class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> <span class="title class_">Acceptor</span>(serverChannel, selector));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());   <span class="comment">//通过dispatch方法进行分发</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过此方法进行分发</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span> <span class="operator">=</span> key.attachment();   <span class="comment">//获取attachment，ServerSocketChannel和对应的客户端Channel都添加了的</span></span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();   <span class="comment">//由于Handler和Acceptor都实现自Runnable接口，这里就统一调用一下</span></span><br><span class="line">        &#125;   <span class="comment">//这样就实现了对应的时候调用对应的Handler或是Acceptor了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用了记得关，保持好习惯，就像看完视频要三连一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        serverChannel.close();</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们编写一下主类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建Reactor对象，启动，完事</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Reactor</span> <span class="variable">reactor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reactor</span>())&#123;</span><br><span class="line">        reactor.run();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了单线程Reactor模式，注意全程使用到的都只是一个线程，没有创建新的线程来处理任何事情。</p>
<p>我们还是使用IO多路复用的那个客户端代码</p>
<img src="https://s2.loli.net/2023/08/02/Kfw2AVjSaXnkF8p.png" alt="image-20230802212933391" style="zoom:50%;" />





<p>但是单线程始终没办法应对大量的请求，如果请求量上去了，单线程还是很不够用，接着我们来看看多线程Reactor模式，它创建了多个线程处理，我们可以将数据读取完成之后的操作交给线程池来执行：</p>
<p><img src="https://s2.loli.net/2023/03/06/DlMSEZ2dvc3pQHJ.png" alt="image-20230306173555763"></p>
<p>其实我们只需要稍微修改一下Handler就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">		<span class="comment">//把线程池给安排了，10个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            POOL.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">                    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在数据读出之后，就可以将数据处理交给线程池执行。</p>
<p>但是这样感觉还是划分的不够，一个Reactor需要同时处理来自客户端的所有操作请求，显得有些乏力，那么不妨我们将Reactor做成一主多从的模式，让主Reactor只负责Accept操作，而其他的Reactor进行各自的其他操作：</p>
<p><img src="https://s2.loli.net/2023/03/06/1DMlvbdLxpca3f5.png" alt="image-20230306173607113"></p>
<p>现在我们来重新设计一下我们的代码，Reactor类就作为主节点，不进行任何修改，我们来修改一下其他的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubReactor作为从Reactor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubReactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Closeable &#123;</span><br><span class="line">		<span class="comment">//每个从Reactor也有一个Selector</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//创建一个4线程的线程池，也就是四个从Reactor工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SubReactor[] reactors = <span class="keyword">new</span> <span class="title class_">SubReactor</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">selectedIndex</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//采用轮询机制，每接受一个新的连接，就轮询分配给四个从Reactor</span></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//在一开始的时候就让4个从Reactor跑起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reactors[i] = <span class="keyword">new</span> <span class="title class_">SubReactor</span>();</span><br><span class="line">                POOL.submit(reactors[i]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//轮询获取下一个Selector（Acceptor用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">nextSelector</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> reactors[selectedIndex].selector;</span><br><span class="line">        selectedIndex = (selectedIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SubReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">//启动后直接等待selector监听到对应的事件即可，其他的操作逻辑和Reactor一致</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.dispatch(iterator.next());</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">att</span> <span class="operator">=</span> key.attachment();</span><br><span class="line">        <span class="keyword">if</span>(att <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">            ((Runnable) att).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来修改一下Acceptor类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;   <span class="comment">//只需要一个ServerSocketChannel就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();   <span class="comment">//还是正常进行Accept操作，得到SocketChannel</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 客户端已连接，IP地址为：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> SubReactor.nextSelector();   <span class="comment">//选取下一个从Reactor的Selector</span></span><br><span class="line">            selector.wakeup();    <span class="comment">//在注册之前唤醒一下防止卡死</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="keyword">new</span> <span class="title class_">Handler</span>(channel));  <span class="comment">//注意现在注册的是从Reactor的Selector</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，SocketChannel相关的操作就由从Reactor进行处理了，而不是一律交给主Reactor进行操作。</p>
<p>至此，我们已经了解了NIO的三大组件：<em>Buffer、Channel、Selector</em></p>
<h3 id="不同网络通信之间的比较"><a href="#不同网络通信之间的比较" class="headerlink" title="不同网络通信之间的比较"></a>不同网络通信之间的比较</h3><h4 id="示意图的比较"><a href="#示意图的比较" class="headerlink" title="示意图的比较"></a>示意图的比较</h4><p><img src="https://s2.loli.net/2023/08/03/9gZrTejdsGDEtca.png" alt="image-20230803124301054"></p>
<p><img src="https://s2.loli.net/2023/08/03/4y6xNdKFfmivCwV.png" alt="image-20230803124317687"></p>
<p><img src="https://s2.loli.net/2023/08/03/ug5rkTYbQtZwlHx.png" alt="image-20230803125820656"></p>
<h4 id="代码的比较"><a href="#代码的比较" class="headerlink" title="代码的比较"></a>代码的比较</h4><h5 id="传统阻塞IO-Socket和SocketChannel"><a href="#传统阻塞IO-Socket和SocketChannel" class="headerlink" title="传统阻塞IO Socket和SocketChannel"></a>传统阻塞IO Socket和SocketChannel</h5><img src="https://s2.loli.net/2023/08/03/VXhUvao5q6f2xJ1.png" alt="image-20230803130846893" style="zoom: 50%;" />

<blockquote>
<p>可以看到在服务端</p>
<ul>
<li>一个是new ServerSocket()，一个是ServerSocketChannel.<em>open</em>()，但是ServerSocketChannel可以实现非阻塞，但是ServerSocket只能是阻塞的</li>
<li>同样是调用accept()方法，阻塞等待新的连接到来</li>
<li>一个使用stream 一个使用buffer</li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;补充&#x3D;&#x3D;</p>
<blockquote>
<p><code>ServerSocketChannel</code> 和 <code>SocketChannel</code>的区别</p>
<ol>
<li><p><code>ServerSocketChannel</code>：<code>ServerSocketChannel</code> 是用于监听传入连接请求的通道。它可以绑定到一个特定的端口并监听该端口上的连接。当有客户端请求连接时，<code>ServerSocketChannel</code> 可以接受连接并创建一个 <code>SocketChannel</code> 与客户端进行通信。</p>
</li>
<li><p><code>SocketChannel</code>：<code>SocketChannel</code> 是用于与远程服务器建立连接并进行通信的通道。它可以连接到远程服务器的 IP 地址和端口，并发送和接收数据。</p>
<p>所以可以看到<code>ServerSocketChannel</code>调用<code>accept()方法</code>返回的是一个<code>SocketChannel</code>类型</p>
<p><code>Socket</code>和<code>SocketChannel</code>同理</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>为什么非阻塞模式的通道来实现高效的 I&#x2F;O 多路复用。要基于缓冲区的方式来进行数据的读写？</p>
<ol>
<li>减少系统调用次数：使用缓冲区可以减少系统调用的次数。系统调用是用户程序与操作系统内核之间的交互，它的开销相对较高。通过使用缓冲区，可以一次性读取或写入较大的数据块，从而减少了系统调用的次数，提高了数据传输的效率。</li>
<li>提高数据传输效率：基于缓冲区的方式可以实现批量读取或写入数据。相比逐个字节或逐个字符地读写数据，批量读写可以减少数据传输的开销，提高数据传输的效率。此外，缓冲区还可以使用直接内存（Direct Memory）来提高数据传输的效率，避免了数据在用户空间和内核空间之间的拷贝。</li>
<li>简化数据处理逻辑：通过使用缓冲区，可以将数据从网络中读取到缓冲区中，然后在缓冲区中进行数据处理和操作。这种方式相对于直接在网络中读取数据并进行处理，更加灵活和方便。缓冲区提供了丰富的方法和功能，如读取和写入指定长度的数据、数据的截取和拼接等，使得数据处理逻辑更加清晰和易于实现。</li>
<li>支持异步操作：基于缓冲区的方式可以与非阻塞 I&#x2F;O 模型结合使用，实现异步的数据读写操作。在非阻塞模式下，当没有数据可读或写时，通道不会阻塞程序的执行，而是立即返回。通过使用缓冲区，可以在数据可用时进行读取，而不必等待数据的到达，从而实现高效的异步操作。</li>
</ol>
</blockquote>
<p><img src="https://s2.loli.net/2023/08/03/5zw7d2NgbBM8jys.png" alt="image-20230803131027196"></p>
<blockquote>
<p>和客户端差不多</p>
</blockquote>
<h5 id="阻塞IO与多路复用"><a href="#阻塞IO与多路复用" class="headerlink" title="阻塞IO与多路复用"></a>阻塞IO与多路复用</h5><p><img src="https://s2.loli.net/2023/08/03/KJd4kWRnbfQMmwF.png" alt="image-20230803134134501"></p>
<blockquote>
<ul>
<li>多路复用创建了一个Selector对象，然后将其注册到了ServerSocketChannel对象中</li>
<li>多路复用会监测不同的事件，并根据事件的类型进行不同的操作</li>
<li>为什么要执行iterator.remove()</li>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey</li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h5 id="单线程Reactor"><a href="#单线程Reactor" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h5><img src="https://s2.loli.net/2023/08/03/InTZBCLgb1qKYo8.png" alt="image-20230803140353402" style="zoom:50%;" />

<ul>
<li>new Reactor并执行run方法，这个Reactor是我们定义的</li>
</ul>
<img src="https://s2.loli.net/2023/08/03/qrB47udOaInP3FT.png" alt="image-20230803140501008" style="zoom:50%;" />

<ul>
<li>Reactor对象封装了一个<code>ServerSocketChannel</code>、<code>Selector</code>。由于继承了Runnable接口，所以Main方法中调用run方法只是执行run方法（不是线程启动的start方法）</li>
</ul>
<img src="https://s2.loli.net/2023/08/03/naGCLMjTmKzYFhJ.png" alt="image-20230803140712238" style="zoom: 33%;" />

<ul>
<li>Reactor对象重写的Runnable接口的Run方法，有点眼熟，下面是使用Selector的多路复用，再加上Reactor对象的构造方法，这不是一样的吗</li>
</ul>
<p><img src="https://s2.loli.net/2023/08/03/t1lXdkMfJipqKQI.png" alt="image-20230803141019870"></p>
<ul>
<li>只不过Reactor使用<code>attachment()</code>方法，Selector使用<code>isAcceptable()</code>和<code>isAcceptable()</code></li>
</ul>
<p><img src="https://s2.loli.net/2023/08/03/crEb3yS7o8aYqBl.png" alt="image-20230803141134764"></p>
<ul>
<li>当我使用一个客户端与Main创建的服务端连接时（只是连接），attachment()返回一个<code>Acceptor</code>对象</li>
</ul>
<img src="https://s2.loli.net/2023/08/03/AR6uKGkoxeYaINq.png" alt="image-20230803141614710" style="zoom:33%;" />

<ul>
<li>当我用客户端给它发消息是，它是一个<code>Handler</code>类型</li>
</ul>
<p><img src="https://s2.loli.net/2023/08/03/RWgItj7Th4qDAG6.png" alt="image-20230803141816077"></p>
<ul>
<li>现在我开启了一个Selector的服务端，这个key和上面的next是同样的情况下生成的，即客户端连接上服务端时。</li>
</ul>
<p>我们发现Selector的服务端的<code>attachment</code>是null，这是为什么呢。因为上面已经说到了  他们前面的代码都差不多啊</p>
<img src="https://s2.loli.net/2023/08/03/pDmSJNP9rsct61E.png" alt="image-20230803142335829" style="zoom:50%;" />

<blockquote>
<p>在Reactor对象中，我们在<code>register</code>方法中传入了Acceptor对象，他会通过cas的方式赋值给attachment这个属性</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/08/03/UPFnVTkLqZeayvJ.png" alt="image-20230803143114508"></p>
<ul>
<li>所以在建立连接时，<code>attachment</code>可以获取到<code>Acceptor</code>对象,执行Acceptor对象中的run方法。</li>
</ul>
<p><code>Acceptor</code>对象中还是封装的<code>ServerSocketChannel</code> <code>Selector</code></p>
<p>他会将<code>Handler</code>也注册到其中。注意哈，根据Reactor注册时new的Acceptor，以及Acceptor注册时new的Handler，可以发现他们使用的都是一个<code>ServerSocketChannel</code> <code>Selector</code>对象（Reactor中的）。所以上面说这是单线程的一种。其实和上面IO多路复用使用的Selector差不多。至于多线程，因为继承了Runnbale接口，后面再说</p>
<p><img src="https://s2.loli.net/2023/08/03/promayfujGxK5E3.png" alt="image-20230803144237081"></p>
<ul>
<li>Acceptor对象中的run方法又将Handler对象注册了。现在连接就建立好了，接着我们需要将连接也注册选择器，比如我们需要当这个连接有内容可读时就进行处理</li>
<li>这样下次客户端传输数据的时候，<code>attachment</code>方法获取到的就是<code>Handler</code>对象了，然后读取就行了。</li>
</ul>
<h5 id="多线程Reactor模式-Handler"><a href="#多线程Reactor模式-Handler" class="headerlink" title="多线程Reactor模式-Handler"></a>多线程Reactor模式-Handler</h5><p>创建了多个线程处理，我们可以将数据读取完成之后的操作交给线程池来执行，我们只需要稍微修改一下Handler就行了，在数据读出之后，将数据处理交给线程池执行。</p>
<h5 id="多线程Reactor模式-Reactor"><a href="#多线程Reactor模式-Reactor" class="headerlink" title="多线程Reactor模式-Reactor"></a>多线程Reactor模式-Reactor</h5><p>按上面的代码复现</p>
<h1 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h1><h2 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h2><ul>
<li>客户端关闭导致服务端空轮询<ul>
<li>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的</li>
</ul>
</li>
<li>粘包&#x2F;拆包问题<ul>
<li><p>比如现在我们要发送两个数据包（P1&#x2F;P2），理想情况下，这两个包应该是依次到达服务端，并由服务端正确读取两次数据出来，但是由于上面的机制，可能会出现下面的情况：</p>
<ol>
<li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li>
<li>可能P1和P2的前半部分合在一起发送给了服务端（拆包现象）</li>
<li>可能P1的前半部分就被单独作为一个部分发给了服务端，后面的和P2一起发给服务端（也是拆包现象）</li>
</ol>
</li>
<li><p>对于这种问题，也有一些比较常见的解决方案：</p>
<ol>
<li>消息定长，发送方和接收方规定固定大小的消息长度，例如每个数据包大小固定为200字节，如果不够，空位补空格，只有接收了200个字节之后，作为一个完整的数据包进行处理。</li>
<li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>\r\n</code>，这样就一定需要读取到这样的分隔符才能将前面所有的数据作为一个完整的数据包进行处理。</li>
<li>将消息分为头部和本体，在头部中保存有当前整个数据包的长度，只有在读到足够长度之后才算是读到了一个完整的数据包。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.76.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>Netty并没有使用NIO中提供的ByteBuffer来进行数据装载，而是自行定义了一个ByteBuf类。</p>
<p>那么这个类相比NIO中的ByteBuffer有什么不同之处呢？</p>
<ul>
<li>写操作完成后无需进行<code>flip()</code>翻转。</li>
<li>具有比ByteBuffer更快的响应速度。</li>
<li>动态扩容。</li>
</ul>
<p>首先我们来看看ByteBuf的子类AbstractByteBuf的内部结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title class_">ByteBuf</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> readerIndex;   <span class="comment">//index被分为了读和写，是两个指针在同时工作</span></span><br><span class="line">    <span class="type">int</span> writerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedReaderIndex;    <span class="comment">//mark操作也分两种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedWriterIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxCapacity;    <span class="comment">//最大容量，没错，这玩意能动态扩容</span></span><br></pre></td></tr></table></figure>

<p>读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writerIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBuffer那样还需要进行翻转了。</p>
<p>其中<code>readerIndex</code>和<code>writerIndex</code>之间的部分就是是可读的内容，而<code>writerIndex</code>之后到<code>capacity</code>都是可写的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个初始容量为10的ByteBuf缓冲区，这里的Unpooled是用于快速生成ByteBuf的工具类</span></span><br><span class="line">    <span class="comment">//至于为啥叫Unpooled是池化的意思，ByteBuf有池化和非池化两种，区别在于对内存的复用，我们之后再讨论</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;初始状态：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.writeInt(-<span class="number">888888888</span>);   <span class="comment">//写入一个Int数据</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入Int后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.readShort();   <span class="comment">//无需翻转，直接读取一个short数据出来</span></span><br><span class="line">    System.out.println(<span class="string">&quot;读取Short后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.discardReadBytes();   <span class="comment">//丢弃操作，会将当前的可读部分内容丢到最前面，并且读写指针向前移动丢弃的距离</span></span><br><span class="line">    System.out.println(<span class="string">&quot;丢弃之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">    buf.clear();    <span class="comment">//清空操作，清空之后读写指针都归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;清空之后：&quot;</span>+Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看划分操作是不是和之前一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  	<span class="comment">//我们也可以将一个byte[]直接包装进缓冲区（和NIO是一样的）不过写指针的值一开始就跑到最后去了，但是这玩意是不是只读的</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="string">&quot;abcdefg&quot;</span>.getBytes());</span><br><span class="line">  	<span class="comment">//除了包装，也可以复制数据，copiedBuffer()会完完整整将数据拷贝到一个新的缓冲区中</span></span><br><span class="line">    buf.readByte();   <span class="comment">//读取一个字节</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> buf.slice();   <span class="comment">//现在读指针位于1，然后进行划分</span></span><br><span class="line"></span><br><span class="line">    System.out.println(slice.arrayOffset());   <span class="comment">//得到划分出来的ByteBuf的偏移地址</span></span><br><span class="line">    System.out.println(Arrays.toString(slice.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，划分也是根据当前读取的位置来进行的。</p>
<p>我们继续来看看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);    <span class="comment">//容量只有10字节</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">  	<span class="comment">//直接写一个字符串</span></span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);   <span class="comment">//很明显这么多字已经超过10字节了</span></span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们发现，在写入一个超出当前容量的数据时，会进行动态扩容,debug代码发现，先计算需要扩容的容量，如果64不够，就找距他最近的2的n次方 ，64够就用64.</p>
<p><img src="https://s2.loli.net/2023/08/03/hRZxTwVsbqFg2SQ.png" alt="image-20230803230458296"></p>
<p>当然如果我们不希望它扩容，可以指定最大容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//在生成时指定maxCapacity也为10</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">    buf.writeCharSequence(<span class="string">&quot;卢本伟牛逼！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(buf.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到现在无法再动态扩容了，至于为什么呢，原来是指定了最大的容量，上面debug的时候可以看到不传maxCapacity的时候，maxCapacity值为2147483647.</p>
<p><img src="https://s2.loli.net/2023/08/03/DqUgiP6oxsHKcOb.png" alt="image-20230803231055059"></p>
<p><img src="https://s2.loli.net/2023/03/06/MyE5vbO1Vhpoxzj.png" alt="image-20230306173824953"></p>
<p>我们接着来看一下缓冲区的三种实现模式：</p>
<ul>
<li>堆缓冲区模式</li>
<li>直接缓冲区模式</li>
<li>复合缓冲区模式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建堆缓冲区</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">heapBuf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        heapBuf.writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;堆缓冲区的数据：&quot;</span>+Arrays.toString(heapBuf.array()));</span><br><span class="line">        System.out.println(<span class="string">&quot;堆缓冲区的数据：&quot;</span>+heapBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//创建直接缓冲区</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">directBuf</span> <span class="operator">=</span> Unpooled.directBuffer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//添加数据</span></span><br><span class="line">        directBuf.writeBytes(<span class="string">&quot;world&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//不能直接拿到数组，因为底层压根不是数组实现的</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;直接缓冲区的数据：&quot;+Arrays.toString(directBuf.array()));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;直接缓冲区的数据：&quot;</span>+directBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//创建复合缓冲区</span></span><br><span class="line">        <span class="type">CompositeByteBuf</span> <span class="variable">compositeBuf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">        <span class="comment">//将堆缓冲区放入复合缓冲区</span></span><br><span class="line">        compositeBuf.addComponent(<span class="literal">true</span>, heapBuf);</span><br><span class="line">        <span class="comment">//将直接缓冲区放入复合缓冲区</span></span><br><span class="line">        compositeBuf.addComponent(<span class="literal">true</span>, directBuf);</span><br><span class="line">        <span class="comment">//打印复合缓冲区的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;复合缓冲区的数据：&quot;</span>+compositeBuf.toString(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于复合缓冲区模式，可以任意地拼凑组合其他缓冲区，如果我们想要对两个缓冲区组合的内容进行操作，我们就不用再单独创建一个新的缓冲区了，而是直接将其进行拼接操作，相当于是作为多个缓冲区组合的视图。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个复合缓冲区</span></span><br><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>) buf.getByte(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们也可以正常操作组合后的缓冲区。</p>
<p><img src="https://s2.loli.net/2023/08/04/WF8iqjVoeGLRnQc.png" alt="image-20230804102251189"></p>
<blockquote>
<p>往<code>CompositeByteBuf</code>里面添加缓冲区时，调用<code>addComponent</code>方法，再通过<code>getByte</code>方法实际上是找里面的添加的缓冲区的array数组</p>
</blockquote>
<p>在之前我们都是通过<code>Unpooled</code>类的方法创建缓冲区</p>
<ul>
<li>创建堆缓冲区 ByteBuf heapBuf &#x3D; Unpooled.buffer(10);</li>
<li>创建直接缓冲区 ByteBuf directBuf &#x3D; Unpooled.directBuffer(10);</li>
<li>创建复合缓冲区 CompositeByteBuf buf &#x3D; Unpooled.compositeBuffer();</li>
</ul>
<p>这样创建的称之为非池化缓冲区，那么相对应的就有池化缓冲区</p>
<p>我们研究一下Unpooled工具类中具体是如何创建buffer的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unpooled</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBufAllocator ALLOC;  <span class="comment">//实际上内部是有一个ByteBufAllocator对象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder BIG_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteOrder LITTLE_ENDIAN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">buffer</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.heapBuffer(initialCapacity);   <span class="comment">//缓冲区的创建操作实际上是依靠ByteBufAllocator来进行的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CompositeByteBuf <span class="title function_">compositeBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compositeBuffer(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title function_">directBuffer</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ALLOC.directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//ALLOC在静态代码块中进行指定，实际上真正的实现类是UnpooledByteBufAllocator</span></span><br><span class="line">        ALLOC = UnpooledByteBufAllocator.DEFAULT;</span><br><span class="line">        BIG_ENDIAN = ByteOrder.BIG_ENDIAN;</span><br><span class="line">        LITTLE_ENDIAN = ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">        EMPTY_BUFFER = ALLOC.buffer(<span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//空缓冲区容量和最大容量都是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> EMPTY_BUFFER <span class="keyword">instanceof</span> EmptyByteBuf : <span class="string">&quot;EMPTY_BUFFER must be an EmptyByteBuf.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们来看看，这个ByteBufAllocator又是个啥，顾名思义，其实就是负责分配缓冲区的。</p>
<p>它有两个具体实现类：<code>UnpooledByteBufAllocator</code>和<code>PooledByteBufAllocator</code>，一个是非池化缓冲区生成器，还有一个是池化缓冲区生成器，那么池化和非池化有啥区别呢？</p>
<p>实际上池化缓冲区利用了池化思想，将缓冲区通过<code>设置内存池来进行内存块复用</code>，这样就不用频繁地进行内存的申请，尤其是在使用堆外内存的时候，避免多次重复通过底层<code>malloc()</code>函数系统调用申请内存造成的性能损失。Netty的内存管理机制主要是借鉴Jemalloc内存分配策略，感兴趣的小伙伴可以深入了解一下。</p>
<p>所以，由于是复用内存空间，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> PooledByteBufAllocator.DEFAULT;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//申请一个容量为10的直接缓冲区</span></span><br><span class="line">    buf.writeChar(<span class="string">&#x27;T&#x27;</span>);    <span class="comment">//随便操作操作</span></span><br><span class="line">    System.out.println(buf.readChar());</span><br><span class="line">    buf.release();    <span class="comment">//释放此缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> allocator.directBuffer(<span class="number">10</span>);   <span class="comment">//重新再申请一个同样大小的直接缓冲区</span></span><br><span class="line">    System.out.println(buf2 == buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在我们使用完一个缓冲区之后，我们将其进行资源释放，当我们再次申请一个同样大小的缓冲区时，会直接得到之前已经申请好的缓冲区，所以，PooledByteBufAllocator实际上是将ByteBuf实例放入池中在进行复用。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h4><p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p>
<img src="https://s2.loli.net/2023/03/06/vFAi9dKxq72XngD.png" alt="image-20230306174025216" style="zoom: 33%;" />

<p>比如我们Java中创建一个新的线程，实际上最终是要交给操作系统来为我们进行分配的，而需要操作系统帮助我们完成任务则需要进行系统调用，是内核在进行处理，不是我们自己的程序在处理，这时就相当于我们的程序处于了内核态，而当操作系统底层分配完成，最后到我们Java代码中返回得到线程对象时，又继续由我们的程序进行操作，所以从内核态转换回了用户态。</p>
<p>而我们的文件操作也是这样，我们实际上也是需要让操作系统帮助我们从磁盘上读取文件数据或是向网络发送数据，比如使用传统IO的情况下，我们要从磁盘上读取文件然后发送到网络上，就会经历以下流程：</p>
<p><img src="https://s2.loli.net/2023/03/06/IYerlt95BLyFh7X.png" alt="image-20230306174033340"></p>
<p>可以看到整个过程中是经历了2次CPU拷贝+2次DMA拷贝，一共四次拷贝。</p>
<p>以传统的 IO 将一个文件通过 socket 写出为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>

<p>内部工作流程是这样的：</p>
<img src="https://s2.loli.net/2023/08/04/ONvZErY8m2QISXj.png" alt="image-20230804104212769" style="zoom:33%;" />

<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，期间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<p>虽然逻辑比较清晰，但是数据老是这样来回进行复制，是不是太浪费时间了点？所以我们就需要寻找一种更好的方式，来实现零拷贝。Netty就为我们做了这个工作</p>
<h4 id="零拷贝方案"><a href="#零拷贝方案" class="headerlink" title="零拷贝方案"></a>零拷贝方案</h4><h5 id="使用虚拟内存"><a href="#使用虚拟内存" class="headerlink" title="使用虚拟内存"></a>使用虚拟内存</h5><p>现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p>
<img src="https://s2.loli.net/2023/03/06/Kfi9uo32CYTHO6e.png" alt="image-20230306174044056" style="zoom:33%;" />

<h5 id="使用mmap-x2F-write内存映射"><a href="#使用mmap-x2F-write内存映射" class="headerlink" title="使用mmap&#x2F;write内存映射"></a>使用mmap&#x2F;write内存映射</h5><p>实际上这种方式就是将内核空间中的缓存直接映射到用户空间缓存，比如NIO中使用的MappedByteBuffer，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了：</p>
<img src="https://s2.loli.net/2023/03/06/3lEWLi8DsrCUSMg.png" alt="image-20230306174056380" style="zoom:33%;" />

<p>不过这样还是会出现用户态和内核态的切换，我们得再优化优化。</p>
<h5 id="使用sendfile方式"><a href="#使用sendfile方式" class="headerlink" title="使用sendfile方式"></a>使用sendfile方式</h5><p>在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝拷贝到Socket上，直接在内核空间中一步到位：</p>
<img src="https://s2.loli.net/2023/03/06/CJraDsyKBEnie1z.png" alt="image-20230306174108253" style="zoom:33%;" />

<p>比如我们之前在NIO中使用的<code>transferTo()</code>方法，就是利用了这种机制来实现零拷贝的。</p>
<img src="https://s2.loli.net/2023/08/04/WxBzGDRchVp27wr.png" alt="image-20230804105112847" style="zoom:33%;" />

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<h5 id="Netty的DirectByteBuf"><a href="#Netty的DirectByteBuf" class="headerlink" title="Netty的DirectByteBuf"></a>Netty的DirectByteBuf</h5><ul>
<li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存 </li>
<li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<img src="https://s2.loli.net/2023/08/04/JdQHU1ZKIoE5S7c.png" alt="image-20230804104924276" style="zoom:33%;" />

<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<h5 id="linux-2-4"><a href="#linux-2-4" class="headerlink" title="linux 2.4"></a>linux 2.4</h5><img src="https://s2.loli.net/2023/08/04/dm1pznK5TwxgNOS.png" alt="image-20230804105817216" style="zoom:33%;" />

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。</p>
<p>所谓的【零拷贝】，并不是真正无拷贝，而是不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h3><p>NIO中我们使用了Reactor模式，而Netty正是以主从Reactor多线程模型为基础，构建出了一套高效的工作模型。</p>
<p>大致工作模型图如下：</p>
<p><img src="https://s2.loli.net/2023/03/06/7qrSNvm6ePpMd9H.png" alt="image-20230306174117322"></p>
<p>可以看到，和我们之前的主从Reactor多线程模型非常类似：</p>
<p><img src="https://s2.loli.net/2023/03/06/pWGVdnqsmjucClJ.png" alt="image-20230306174127616"></p>
<p>所有的客户端需要连接到主Reactor完成Accept操作后，其他的操作由从Reactor去完成，这里也是差不多的思想，但是它进行了一些改进，我们来看一下它的设计：</p>
<ul>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接受客户端的连接, WorkerGroup专门负读写，就像我们前面说的主从Reactor一样。</li>
<li>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环机制，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听的，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop了而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorkerGroup的具体实现。</li>
<li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听。</li>
</ul>
<p>听起来很迷糊，还是上代码吧</p>
<ol>
<li>创建一个Netty服务器：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个netty服务器</span></span><br><span class="line">    <span class="comment">//1. 创建BossGroup</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">//2. 创建WorkerGroup</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">//以上我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">//3. 创建服务端启动助手</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">//4. 设置bossGroup和workerGroup,指定事件循环组</span></span><br><span class="line">    serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">            <span class="comment">//5. 设置服务端通道实现为NIO</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            <span class="comment">//6. 设置服务端处理器</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的，ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                    <span class="comment">//7. 向pipeline中添加自定义业务处理handler,当我们需要处理客户端的数据时，实际上是像流水线一样在处理，</span></span><br><span class="line">                    <span class="comment">// 这个流水线上可以有很多Handler,每个Handler都有自己的功能，比如解码、编码、业务处理等等</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            <span class="comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式</span></span><br><span class="line">                            <span class="comment">//8. 自定义业务处理逻辑</span></span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 服务端接收到数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//9. 启动服务端并绑定端口</span></span><br><span class="line">    serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着编写一个客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">             <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经连接上服务器，可以开始通信了&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (msg.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//直接向通道中写入数据</span></span><br><span class="line">                socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">                System.out.println(<span class="string">&quot;已发送数据：&quot;</span> + msg);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">allocate</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                socketChannel.read(allocate);</span><br><span class="line">                allocate.flip();</span><br><span class="line">                System.out.println(<span class="string">&quot;收到服务端的数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(allocate.array()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过通道正常收发数据即可，这样我们就成功搭建好了一个Netty服务器。</p>
<p><img src="https://s2.loli.net/2023/08/04/PvWXAaBNeHwkdS6.png" alt="image-20230804122117457"></p>
<h3 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h3><p>在NIO时，我们就已经接触到Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输。</p>
<p>而在Netty中，也有对应的Channel类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">AttributeMap</span>, ChannelOutboundInvoker, Comparable&lt;Channel&gt; &#123;</span><br><span class="line">    ChannelId <span class="title function_">id</span><span class="params">()</span>;   <span class="comment">//通道ID</span></span><br><span class="line">    EventLoop <span class="title function_">eventLoop</span><span class="params">()</span>;   <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    Channel <span class="title function_">parent</span><span class="params">()</span>;   <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    ChannelConfig <span class="title function_">config</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;   <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span>;</span><br><span class="line">    ChannelMetadata <span class="title function_">metadata</span><span class="params">()</span>;   <span class="comment">//通道相关信息</span></span><br><span class="line">    SocketAddress <span class="title function_">localAddress</span><span class="params">()</span>; </span><br><span class="line">    SocketAddress <span class="title function_">remoteAddress</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">closeFuture</span><span class="params">()</span>;  <span class="comment">//关闭通道，但是会用到ChannelFuture</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeUnwritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeWritable</span><span class="params">()</span>;</span><br><span class="line">    Unsafe <span class="title function_">unsafe</span><span class="params">()</span>;</span><br><span class="line">    ChannelPipeline <span class="title function_">pipeline</span><span class="params">()</span>;   <span class="comment">//流水线</span></span><br><span class="line">    ByteBufAllocator <span class="title function_">alloc</span><span class="params">()</span>;   <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    Channel <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    Channel <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Netty中的Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p>
<ul>
<li><p>所有的IO操作都是异步的，并不是在当前线程同步运行，方法调用之后就直接返回了，那怎么获取操作的结果呢？使用ChannelFuture完成的,ChannelFuture继承了JUC包下的Future。</p>
</li>
<li><pre><code class="java">public interface ChannelFuture extends Future&lt;Void&gt; &#123;
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以来看一下Channel接口的父接口ChannelOutboundInvoker接口，这里面定义了大量的I/O操作：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface ChannelOutboundInvoker &#123;   //通道出站调用（包含大量的网络出站操作，比如写）</span><br><span class="line">    ChannelFuture bind(SocketAddress var1);  //Socket绑定、连接、断开、关闭等操作</span><br><span class="line">    ChannelFuture connect(SocketAddress var1);</span><br><span class="line">    ChannelFuture connect(SocketAddress var1, SocketAddress var2);</span><br><span class="line">    ChannelFuture disconnect();</span><br><span class="line">    ChannelFuture close();</span><br><span class="line">    ChannelFuture deregister();</span><br><span class="line">    ChannelFuture bind(SocketAddress var1, ChannelPromise var2);    //ChannelPromise其实就是ChannelFuture的增强版</span><br><span class="line">    ChannelFuture connect(SocketAddress var1, ChannelPromise var2);</span><br><span class="line">    ChannelFuture connect(SocketAddress var1, SocketAddress var2, ChannelPromise var3);</span><br><span class="line">    ChannelFuture disconnect(ChannelPromise var1);</span><br><span class="line">    ChannelFuture close(ChannelPromise var1);</span><br><span class="line">    ChannelFuture deregister(ChannelPromise var1);</span><br><span class="line">    ChannelOutboundInvoker read();</span><br><span class="line">  </span><br><span class="line">    ChannelFuture write(Object var1);    //可以看到这些常见的写操作，都是返回的ChannelFuture，而不是直接给结果</span><br><span class="line">    ChannelFuture write(Object var1, ChannelPromise var2);</span><br><span class="line">    ChannelOutboundInvoker flush();</span><br><span class="line">    ChannelFuture writeAndFlush(Object var1, ChannelPromise var2);</span><br><span class="line">    ChannelFuture writeAndFlush(Object var1);</span><br><span class="line">  </span><br><span class="line">    ChannelPromise newPromise();   </span><br><span class="line">    ChannelProgressivePromise newProgressivePromise();</span><br><span class="line">    ChannelFuture newSucceededFuture();</span><br><span class="line">    ChannelFuture newFailedFuture(Throwable var1);</span><br><span class="line">    ChannelPromise voidPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>当然它还实现了AttributeMap接口，其实有点类似于Session那种感觉，我们可以添加一些属性之类的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AttributeMap</span> &#123;</span><br><span class="line">    &lt;T&gt; Attribute&lt;T&gt; <span class="title function_">attr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h5><p>我们了解了Netty底层的Channel之后，我们接着来看ChannelHandler。</p>
<p>既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前Reactor模式中的Handler，全靠它来处理读写操作。</p>
<p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，就是后面会介绍的ChannelPipeline。</p>
<p>比如我们上面就是使用了ChannelInboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  </span><br><span class="line">      	<span class="comment">//ctx是上下文，msg是收到的消息，以ByteBuf形式</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们先从顶层接口开始看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">  	<span class="comment">//当ChannelHandler被添加到流水线中时调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//当ChannelHandler从流水线中移除时调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Sharable &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶层接口的定义比较简单，就只有一些流水线相关的回调方法，我们接着来看下一级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ChannelInboundHandler用于处理入站相关事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">  	<span class="comment">//当Channel已经注册到自己的EventLoop上时调用，前面我们说了，一个Channel只会注册到一个EventLoop上，注册到EventLoop后，这样才会在发生对应事件时被通知。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//从EventLoop上取消注册时</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//当Channel已经处于活跃状态时被调用，此时Channel已经连接/绑定，并且已经就绪</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//跟上面相反，不再活跃了，并且不在连接它的远程节点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//当从Channel读取数据时被调用，可以看到数据被自动包装成了一个Object（默认是ByteBuf）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//上一个读取操作完成后调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//暂时不介绍</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//当Channel的可写状态发生改变时被调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">		<span class="comment">//出现异常时被调用</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们上面用到的ChannelInboundHandlerAdapter实际上就是对这些方法实现的抽象类，相比直接用接口，我们可以只重写我们需要的方法，没有重写的方法会默认向流水线下一个ChannelHandler发送。</p>
<p>我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        <span class="comment">//将我们自定义的ChannelHandler添加到流水线</span></span><br><span class="line">                        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TestChannelHandler</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">back</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(back);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userEventTriggered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelWritabilityChanged&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器，让客户端来连接并发送一下数据试试看：</p>
<img src="https://s2.loli.net/2023/08/04/1ONmtSJkxeFZaDV.png" alt="image-20230804125505806" style="zoom:50%;" />

<p>可以看到ChannelInboundHandler的整个生命周期，首先是Channel注册成功，然后才会变成可用状态，接着就差不多可以等待客户端来数据了，当客户端主动断开连接时，会再次触发一次<code>channelReadComplete</code>，然后不可用，最后取消注册。</p>
<p>与ChannelInboundHandler对应的还有ChannelOutboundHandler用于处理出站相关的操作。</p>
<p>出站相关操作，我们可以使用ChannelOutboundHandlerAdapter来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;   </span><br><span class="line">              <span class="comment">//注意出栈站操作应该在入站操作的前面，当我们使用ChannelHandlerContext的write方法时，是从流水线的当前位置倒着往前找下一个ChannelOutboundHandlerAdapter，而我们之前使用的ChannelInboundHandlerAdapter是从前往后找下一个，如果我们使用的是Channel的write方法，那么会从整个流水线的最后开始倒着往前找ChannelOutboundHandlerAdapter，一定要注意顺序。</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;  <span class="comment">//当执行write操作时，会</span></span><br><span class="line">                    System.out.println(msg);   <span class="comment">//write的是啥，这里就是是啥</span></span><br><span class="line">                  	<span class="comment">//我们将其转换为ByteBuf，这样才能发送回客户端</span></span><br><span class="line">                    ctx.writeAndFlush(Unpooled.wrappedBuffer(msg.toString().getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.fireChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                    ctx.writeAndFlush(<span class="string">&quot;啊对对对&quot;</span>);   <span class="comment">//这里可以write任何对象</span></span><br><span class="line">                  	<span class="comment">//ctx.channel().writeAndFlush(&quot;啊对对对&quot;); 或是通过Channel进行write也可以</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来试试看，搞两个出站的Handler，验证一下是不是上面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 增加自定义的非NioEventLoopGroup</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> &#123;</span><br><span class="line">                    <span class="comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span></span><br><span class="line">                    socketChannel.pipeline().addLast(<span class="string">&quot;nioHandler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    <span class="comment">// 调用下一个handler</span></span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            <span class="comment">// 该handler绑定自定义的Group</span></span><br><span class="line">                            .addLast(group, <span class="string">&quot;myHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    ctx.channel().writeAndFlush(buf);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;outbound2&quot;</span>);</span><br><span class="line">                                    ctx.writeAndFlush(msg);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            &#125;)</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;outbound1&quot;</span>);</span><br><span class="line">                                    ctx.write(msg);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            &#125;)</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，出站操作在流水线上是反着来的，整个流水线操作大概流程如下</p>
<img src="https://s2.loli.net/2023/08/06/HrRDFvQnE652sdA.png" alt="image-20230806172107477" style="zoom:50%;" />

<blockquote>
<p>可以看到，对于<code>ChannelInboundHandlerAdapter</code>,我们重写了channelRead方法，如果不重写，它会直接调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>fireChannelRead</code>就是传到下一个入站的Handler，但是我们重写了，所以我们需要正在重写中显式的调用<code>fireChannelRead</code>方法，对于最后一个<code>ChannelInboundHandlerAdapter</code>我们则需要使用<code> ctx.writeAndFlush(msg);</code>将消息刷回通道。但是注意，我们使用的是<code>ctx.channel().writeAndFlush(buf);</code>这是为什么呢？</p>
<ul>
<li>ctx.writeAndFlush会在当前调用这个方法的入栈Handler反向寻找出站Handler</li>
<li>ctx.channel().writeAndFlush(buf)，则是从tail往后找。</li>
</ul>
<p>对于第一个<code>ChannelOutboundHandlerAdapter</code>,我们重写了<code>write</code>方法，如果补充些，他会直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>write</code>就是向前寻找下一个<code>ChannelOutboundHandlerAdapter</code>，但是我们重写了，所以我们需要正在重写中显式的调用<code>write</code>方法，最后一个<code>ChannelOutboundHandlerAdapter</code>还是一样，使用<code> ctx.writeAndFlush(msg);</code>将消息刷回通道。然后结束了。</p>
</blockquote>
<ol>
<li>ctx.channel().writeAndFlush()</li>
</ol>
<p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></a></p>
<ol start="2">
<li>ctx.writeAndFlush()</li>
</ol>
<p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></a></p>
<p>我们来测试一下出现异常的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">back</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(back);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;测试异常1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;测试异常2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2023/08/05/DYZKjrTe26sF5lV.png" alt="image-20230804132737108" style="zoom:33%;" />

<blockquote>
<p> 可以看到发生异常时，会接着调用<code>exceptionCaught</code>方法：</p>
</blockquote>
<h5 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h5><p>每一个Channel都对应一个ChannelPipeline（在Channel初始化时就被创建了）</p>
<img src="https://s2.loli.net/2023/03/06/lSAjPCskUT9miNd.png" alt="image-20230306174211952" style="zoom: 33%;" />

<p>它就像是一条流水线一样，整条流水线上可能会有很多个Handler（包括入站和出站），整条流水线上的两端还有两个默认的处理器（用于一些预置操作和后续操作，比如释放资源等），我们只需要关心如何安排这些自定义的Handler即可，比如我们现在希望创建两个入站ChannelHandler，一个用于接收请求并处理，还有一个用于处理当前接收请求过程中出现的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        <span class="comment">//将我们自定义的ChannelHandler添加到流水线</span></span><br><span class="line">                        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">back</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                                ctx.writeAndFlush(back);</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;测试异常1&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/08/04/vNSL56TRshmxiEC.png" alt="image-20230804135713479"></p>
<p>那么它是如何运作的呢？实际上如果我们不在ChannelInboundHandlerAdapter中重写对应的方法，它会默认传播到流水线的下一个ChannelInboundHandlerAdapter进行处理，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ctx.fireExceptionCaught(cause);   <span class="comment">//通过ChannelHandlerContext来向下传递，ChannelHandlerContext是在Handler添加进Pipeline中时就被自动创建的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们现在需要将一个消息在两个Handler中进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            <span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    <span class="comment">//将我们自定义的ChannelHandler添加到流水线</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                            System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            ctx.fireChannelRead(msg);   <span class="comment">//通过ChannelHandlerContext</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                            System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            ctx.fireChannelRead(msg);   <span class="comment">//通过ChannelHandlerContext</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2023/08/04/3nopPJ1i9AMa6Fe.png" alt="image-20230804140427116" style="zoom: 50%;" />

<h3 id="EventLoop和任务调度"><a href="#EventLoop和任务调度" class="headerlink" title="EventLoop和任务调度"></a>EventLoop和任务调度</h3><p>Channel在EventLoop中具体是如何进行调度的呢？实际上我们之前在编写NIO的时候，就是一个while循环在源源不断地等待新的事件，而EventLoop也正是这种思想，它本质就是一个事件等待&#x2F;处理线程。</p>
<img src="https://s2.loli.net/2023/03/06/6Z1evQGNayObnD5.png" alt="image-20230306174245836" style="zoom: 33%;" />

<p>我们上面使用的就是EventLoopGroup，包含很多个EventLoop，我们每创建一个连接，就需要绑定到一个EventLoop上，之后EventLoop就会开始监听这个连接（&#x3D;&#x3D;只要连接不关闭，一直都是这个EventLoop负责此Channel&#x3D;&#x3D;），而一个EventLoop可以同时监听很多个Channel，实际上就是我们之前学习的Selector罢了。</p>
<p>当然，EventLoop并不只是用于网络操作的，我们前面所说的EventLoop其实都是NioEventLoop，它是专用于网络通信的，除了网络通信之外，我们也可以使用普通的EventLoop来处理一些其他的事件。</p>
<p>比如我们现在编写的服务端，虽然结构上和主从Reactor多线程模型差不多，但是我们发现，Handler似乎是和读写操作在一起进行的，而我们之前所说的模型中，Handler是在读写之外的单独线程中进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    Thread.sleep(<span class="number">10000</span>);   <span class="comment">//这里我们直接卡10秒假装在处理任务</span></span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果在这里卡住了，那么就没办法处理EventLoop绑定的其他Channel了，所以我们这里就创建一个普通的EventLoop来专门处理读写之外的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                  	System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    handlerGroup.submit(() -&gt; &#123;   </span><br><span class="line">                                <span class="comment">//由于继承自ScheduledExecutorService，我们直接提交任务就行了，是不是感觉贼方便</span></span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以写成一条流水线：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).addLast(handlerGroup, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;  <span class="comment">//在添加时，可以直接指定使用哪个EventLoopGroup</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就进一步地将EventLoop利用起来了。</p>
<p>按照前面服务端的方式，我们来把Netty版本的客户端也给写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();   <span class="comment">//客户端也是使用Bootstrap来启动</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())   <span class="comment">//客户端就没那么麻烦了，直接一个EventLoop就行，用于处理发回来的数据</span></span><br><span class="line">            .channel(NioSocketChannel.class)   <span class="comment">//客户端肯定就是使用SocketChannel了</span></span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   <span class="comment">//这里的数据处理方式和服务端是一样的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;   </span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                            System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();  <span class="comment">//连接后拿到对应的Channel对象</span></span><br><span class="line">  	<span class="comment">//注意上面连接操作是异步的，调用之后会继续往下走，下面我们就正式编写客户端的数据发送代码了</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;    <span class="comment">//还是和之前一样，扫了就发</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));  <span class="comment">//通过Channel对象发送数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试一下吧：</p>
<img src="https://s2.loli.net/2023/03/06/cnbxqteVo62da8p.png" alt="image-20230306174303352" style="zoom:33%;" />

<h3 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h3><p>我们接着来看ChannelFuture，前面我们提到，Netty中Channel的相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果，如果需要得到结果，那么我们就必须要利用到Future。</p>
<p>我们先来看看ChannelFutuer接口怎么定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;    <span class="comment">//我们可以直接获取此任务的Channel</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; var1)</span>;  <span class="comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;   <span class="comment">//在当前线程同步等待异步任务完成，任务失败会抛出异常</span></span><br><span class="line">    ChannelFuture <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;   <span class="comment">//同上，但是无法响应中断</span></span><br><span class="line">    ChannelFuture <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;  <span class="comment">//同上，但是任务中断不会抛出异常，需要手动判断</span></span><br><span class="line">    ChannelFuture <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;    <span class="comment">//不用我说了吧？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;   <span class="comment">//返回类型是否为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口是继承自Netty中的Future接口的（不是JDK的那个）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt; &#123;   <span class="comment">//再往上才是JDK的Future</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span>;    <span class="comment">//用于判断任务是否执行成功的</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancellable</span><span class="params">()</span>;</span><br><span class="line">    Throwable <span class="title function_">cause</span><span class="params">()</span>;    <span class="comment">//获取导致任务失败的异常</span></span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">    </span><br><span class="line">    V <span class="title function_">getNow</span><span class="params">()</span>;  <span class="comment">//立即获取结果，如果还未产生结果，得到null，不过ChannelFuture定义V为Void，就算完成了获取也是null</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> var1)</span>;    <span class="comment">//取消任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel的很多操作都是异步完成的，直接返回一个ChannelFuture，比如Channel的write操作，返回的就是一个ChannelFuture对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">        System.out.println(<span class="string">&quot;任务完成状态：&quot;</span>+future.isDone());   <span class="comment">//通过ChannelFuture来获取相关信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>包括我们的服务端启动也是返回的ChannelFuture：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">								&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端的启动就比较慢了，所以在一开始直接获取状态会返回<code>false</code>，但是这个时候我们又需要等到服务端启动完成之后做一些事情，这个时候该怎么办呢？现在我们就有两种方案了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    future.sync();   <span class="comment">//让当前线程同步等待任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">    System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方案是直接让当前线程同步等待异步任务完成，我们可以使用<code>sync()</code>方法，这样当前线程会一直阻塞直到任务结束。第二种方案是添加一个监听器，等待任务完成时通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">		<span class="comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span></span><br><span class="line">    future.addListener(f -&gt; System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括客户端的关闭，也是异步进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(text.equals(<span class="string">&quot;exit&quot;</span>)) &#123;   <span class="comment">//输入exit就退出</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> channel.close();</span><br><span class="line">            future.sync();    <span class="comment">//等待Channel完全关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(Unpooled.wrappedBuffer(text.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully();   <span class="comment">//优雅退出EventLoop，其实就是把还没发送的数据之类的事情做完，当然也可以shutdownNow立即关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着来看看Promise接口，它支持手动设定成功和失败的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此接口也是继承自Netty中的Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V var1)</span>;    <span class="comment">//手动设定成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable var1)</span>;  <span class="comment">//手动设定失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line">		<span class="comment">//这些就和之前的Future是一样的了</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>());</span><br><span class="line">    System.out.println(promise.isSuccess());    <span class="comment">//在一开始肯定不是成功的</span></span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);    <span class="comment">//设定成功</span></span><br><span class="line">    System.out.println(promise.isSuccess());   <span class="comment">//再次获取，可以发现确实成功了</span></span><br><span class="line">    System.out.println(promise.get());    <span class="comment">//获取结果，就是我们刚刚给进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们可以手动指定成功状态，包括ChannelOutboundInvoker中的一些基本操作，都是支持ChannelPromise的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buf.toString(StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+text);</span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel);</span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()), promise);</span><br><span class="line">        promise.sync();  <span class="comment">//同步等待一下</span></span><br><span class="line">        System.out.println(promise.isSuccess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后结果就是我们想要的了，当然我们也可以像Future那样添加监听器，当成功时自动通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    Promise&lt;String&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>()); </span><br><span class="line">    promise.addListener(f -&gt; System.out.println(promise.get()));   <span class="comment">//注意是在上面的DefaultEventLoop执行的</span></span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">    promise.setSuccess(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    System.out.println(promise.isSuccess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关Future和Promise就暂时讲解到这里。</p>
<h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>前面我们已经了解了Netty的大部分基础内容，我们接着来看看Netty内置的一些编码器和解码器。</p>
<p>在前面的学习中，我们的数据发送和接收都是需要以ByteBuf形式传输，但是这样是不是有点太不方便了，咱们能不能参考一下JavaWeb那种搞个Filter，在我们开始处理数据之前，过过滤一次，并在过滤的途中将数据转换成我们想要的类型，也可以将发出的数据进行转换，这就要用到编码解码器了。</p>
<p>我们先来看看最简的，字符串，如果我们要直接在客户端或是服务端处理字符串，可以直接添加一个字符串解码器到我们的流水线中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">    channel.pipeline()</span><br><span class="line">            <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())   <span class="comment">//当客户端发送来的数据只是简单的字符串转换的ByteBuf时，我们直接使用内置的StringDecoder即可转换</span></span><br><span class="line">            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">//经过StringDecoder转换后，msg直接就是一个字符串，所以打印就行了</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用起来还是非常方便的，我们只需要将其添加到流水线即可，实际上器本质就是一个ChannelInboundHandlerAdapter：</p>
<p><img src="https://s2.loli.net/2023/03/06/x6Fh48G7PjZqHoW.png" alt="image-20230306174321314"></p>
<p>我们看到它是继承自MessageToMessageDecoder，用于将传入的Message转换为另一种类型，我们也可以自行编写一个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我们也来搞一个自定义的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);   <span class="comment">//解码后需要将解析后的数据丢进List中，如果丢进去多个数据，相当于数据被分成了多个，后面的Handler就需要每个都处理一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，可以看到：</p>
<p><img src="https://s2.loli.net/2023/03/06/aM6gy1BAeLUlEui.png" alt="image-20230306174333758"></p>
<p>当然如果我们在List里面丢很多个数据的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据已收到，正在进行解码...&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> buf.toString(StandardCharsets.UTF_8);  <span class="comment">//直接转换为UTF8字符串</span></span><br><span class="line">        list.add(text);</span><br><span class="line">        list.add(text+<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(text+<span class="string">&#x27;3&#x27;</span>);   <span class="comment">//一条消息被解码成三条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/izRZ8t4BDXPeQbs.png" alt="image-20230306174344121"></p>
<p>可以看到，后面的Handler会依次对三条数据都进行处理，当然，除了MessageToMessageDecoder之外，还有其他类型的解码器，比如ByteToMessageDecoder等，这里就不一一介绍了，Netty内置了很多的解码器实现来方便我们开发，比如HTTP（下一节介绍），SMTP、MQTT等，以及我们常用的Redis、Memcached、JSON等数据包。</p>
<p>当然，有了解码器处理发来的数据，那发出去的数据肯定也是需要被处理的，所以编码器就出现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());  <span class="comment">//使用内置的StringEncoder可以直接将出站的字符串数据编码成ByteBuf</span></span><br></pre></td></tr></table></figure>

<p>和上面的StringDecoder一样，StringEncoder本质上就是一个ChannelOutboundHandlerAdapter：</p>
<p><img src="https://s2.loli.net/2023/03/06/PruXKkgxhOf3bsJ.png" alt="image-20230306174359121"></p>
<p>是不是感觉前面学习的Handler和Pipeline突然就变得有用了，直接一条线把数据处理安排得明明白白啊。</p>
<p>现在我们把客户端也改成使用编码、解码器的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">            .channel(NioSocketChannel.class)</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())  <span class="comment">//解码器安排</span></span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);  <span class="comment">//直接接收字符串</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());  <span class="comment">//编码器安排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">            channel.writeAndFlush(text);  <span class="comment">//直接发送字符串就行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的代码量又蹭蹭的减少了很多：</p>
<p><img src="https://s2.loli.net/2023/03/06/Jh1VqZMD4LRi7f8.png" alt="image-20230306174410560"></p>
<p>当然，除了编码器和解码器之外，还有编解码器。？？缝合怪？？</p>
<p><img src="https://s2.loli.net/2023/03/06/CpcgbnRwSk6dIF5.png" alt="image-20230306174419482"></p>
<p>可以看到它是既继承了ChannelInboundHandlerAdapter也实现了ChannelOutboundHandler接口，又能处理出站也能处理入站请求，实际上就是将之前的给组合到一起了，比如我们也可以实现一个缝合在一起的StringCodec类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要指定两个泛型，第一个是入站的消息类型，还有一个是出站的消息类型，出站是String类型，我们要转成ByteBuf</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCodec</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, String&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理出站数据...&quot;</span>);</span><br><span class="line">        list.add(Unpooled.wrappedBuffer(buf.getBytes()));   <span class="comment">//同样的，添加的数量就是出站的消息数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理入站数据...&quot;</span>);</span><br><span class="line">        list.add(buf.toString(StandardCharsets.UTF_8));  <span class="comment">//和之前一样，直接一行解决</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上就是需要我们同时去实现编码和解码方法，继承MessageToMessageCodec类即可。</p>
<p>当然，如果整条流水线上有很多个解码器或是编码器，那么也可以多次进行编码或是解码，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToStringEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageEncoder</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是预处理编码器，就要皮这一下。&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;[已处理] &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())    <span class="comment">//最后再转成ByteBuf</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringToStringEncoder</span>());  <span class="comment">//先从我们自定义的开始</span></span><br></pre></td></tr></table></figure>

<p>可以看到，数据在流水线上一层一层处理最后再回到的客户端：</p>
<p><img src="https://s2.loli.net/2023/03/06/7f9LpaTQ8OcqMeN.png" alt="image-20230306174519936"></p>
<p>我们在一开始提到的粘包&#x2F;拆包问题，也可以使用一个解码器解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>))  </span><br><span class="line">        <span class="comment">//第一种解决方案，使用定长数据包，每个数据包都要是指定长度</span></span><br><span class="line">  			...</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>, Unpooled.wrappedBuffer(<span class="string">&quot;!&quot;</span>.getBytes())))</span><br><span class="line">        <span class="comment">//第二种，就是指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span></span><br><span class="line">  			<span class="comment">//在收到分隔符之前的所有数据，都作为同一个数据包的内容</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment">//第三种方案，就是在头部添加长度信息，来确定当前发送的数据包具体长度是多少</span></span><br><span class="line">        <span class="comment">//offset是从哪里开始，length是长度信息占多少字节，这里是从0开始读4个字节表示数据包长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldPrepender</span>(<span class="number">4</span>))   <span class="comment">//客户端在发送时也需要将长度拼到前面去</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br></pre></td></tr></table></figure>

<p>有关编码器和解码器的内容就先介绍到这里。</p>
<h3 id="实现HTTP协议通信"><a href="#实现HTTP协议通信" class="headerlink" title="实现HTTP协议通信"></a>实现HTTP协议通信</h3><p>前面我们介绍了Netty为我们提供的编码器和解码器，这里我们就来使用一下支持HTTP协议的编码器和解码器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg.getClass());  <span class="comment">//看看是个啥类型</span></span><br><span class="line">              	<span class="comment">//收到浏览器请求后，我们需要给一个响应回去</span></span><br><span class="line">                <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);  <span class="comment">//HTTP版本为1.1，状态码就OK（200）即可</span></span><br><span class="line">              	<span class="comment">//直接向响应内容中写入数据</span></span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);   <span class="comment">//发送响应</span></span><br><span class="line">                ctx.channel().close();   <span class="comment">//HTTP请求是一次性的，所以记得关闭</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());   <span class="comment">//响应记得也要编码后发送哦</span></span><br></pre></td></tr></table></figure>

<p>现在我们用浏览器访问一下我们的服务器吧：</p>
<p><img src="https://s2.loli.net/2023/03/06/oAlpObgidLQhzE8.png" alt="image-20230306174531740"></p>
<p>可以看到浏览器成功接收到服务器响应，然后控制台打印了以下类型：</p>
<p><img src="https://s2.loli.net/2023/03/06/WoCXiKelwzmYnQI.png" alt="image-20230306174542903"></p>
<p>可以看到一次请求是一个DefaultHttpRequest+LastHttpContent$1，这里有两组是因为浏览器请求了一个地址之后紧接着请求了我们网站的favicon图标。</p>
<p>这样把数据分开处理肯定是不行的，要是直接整合成一个多好，安排：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">                System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">                <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">                response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                ctx.channel().writeAndFlush(response);</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br></pre></td></tr></table></figure>

<p>再次访问，我们发现可以正常读取请求路径了：</p>
<p><img src="https://s2.loli.net/2023/03/06/P3QRD2kHme1Vhga.png" alt="image-20230306174557790"></p>
<p>我们来试试看搞个静态页面代理玩玩，拿出我们的陈年老模板：</p>
<p><img src="https://s2.loli.net/2023/03/06/ITE5izhrG4ZedSO.png" alt="image-20230306174609270"></p>
<p>全部放进Resource文件夹，一会根据浏览器的请求路径，我们就可以返回对应的页面了，先安排一个解析器，用于解析路径然后将静态页面的内容返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResolver</span> &#123;</span><br><span class="line">		<span class="comment">//直接单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PageResolver</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageResolver</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PageResolver</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PageResolver <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//请求路径给进来，接着我们需要将页面拿到，然后转换成响应数据包发回去</span></span><br><span class="line">    <span class="keyword">public</span> FullHttpResponse <span class="title function_">resolveResource</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;/&quot;</span>))  &#123;  <span class="comment">//判断一下是不是正常的路径请求</span></span><br><span class="line">            path = path.equals(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;index.html&quot;</span> : path.substring(<span class="number">1</span>);    <span class="comment">//如果是直接请求根路径，那就默认返回index页面，否则就该返回什么路径的文件就返回什么</span></span><br><span class="line">            <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stream != <span class="literal">null</span>) &#123;   <span class="comment">//拿到文件输入流之后，才可以返回页面</span></span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">                    stream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.OK, bytes);  <span class="comment">//数据先读出来，然后交给下面的方法打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//其他情况一律返回404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.packet(HttpResponseStatus.NOT_FOUND, <span class="string">&quot;404 Not Found!&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//包装成FullHttpResponse，把状态码和数据写进去</span></span><br><span class="line">    <span class="keyword">private</span> FullHttpResponse <span class="title function_">packet</span><span class="params">(HttpResponseStatus status, <span class="type">byte</span>[] data)</span>&#123;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, status);</span><br><span class="line">        response.content().writeBytes(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的静态资源解析就写好了，接着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">              	<span class="comment">//请求进来了直接走解析</span></span><br><span class="line">                <span class="type">PageResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> PageResolver.getInstance();</span><br><span class="line">                ctx.channel().writeAndFlush(resolver.resolveResource(request.uri()));</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br></pre></td></tr></table></figure>

<p>现在我们启动服务器来试试看吧：</p>
<p><img src="https://s2.loli.net/2023/03/06/PpFUKSMXDi5ItjN.png" alt="image-20230306174624966"></p>
<p>可以看到页面可以正常展示了，是不是有Tomcat哪味了。</p>
<h3 id="其他内置Handler介绍"><a href="#其他内置Handler介绍" class="headerlink" title="其他内置Handler介绍"></a>其他内置Handler介绍</h3><p>Netty也为我们内置了一些其他比较好用的Handler，比如我们要打印日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))   <span class="comment">//添加一个日志Handler，在请求到来时会自动打印相关日志</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>日志级别我们选择INFO，现在我们用浏览器访问一下：</p>
<p><img src="https://s2.loli.net/2023/03/06/bFBDTEpi3S6U87N.png" alt="image-20230306174636233"></p>
<p>可以看到每次请求的内容和详细信息都会在日志中出现，包括详细的数据包解析过程，请求头信息都是完整地打印在控制台上的。</p>
<p>我们也可以使用Handler对IP地址进行过滤，比如我们不希望某些IP地址连接我们的服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">RuleBasedIpFilter</span>(<span class="keyword">new</span> <span class="title class_">IpFilterRule</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> !inetSocketAddress.getHostName().equals(<span class="string">&quot;127.0.0.1&quot;</span>);  </span><br><span class="line">              	<span class="comment">//进行匹配，返回false表示匹配失败</span></span><br><span class="line">              	<span class="comment">//如果匹配失败，那么会根据下面的类型决定该干什么，比如我们这里判断是不是本地访问的，如果是那就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> IpFilterRuleType <span class="title function_">ruleType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> IpFilterRuleType.REJECT;   <span class="comment">//类型，REJECT表示拒绝连接，ACCEPT表示允许连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br></pre></td></tr></table></figure>

<p>现在我们浏览器访问一下看看：</p>
<p><img src="https://s2.loli.net/2023/03/06/DlLTroQJdhPcyBO.png" alt="image-20230306174646897"></p>
<p>我们也可以对那些长期处于空闲的进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>))  <span class="comment">//IdleStateHandler能够侦测连接空闲状态</span></span><br><span class="line">        <span class="comment">//第一个参数表示连接多少秒没有读操作时触发事件，第二个是写操作，第三个是读写操作都算，0表示禁用</span></span><br><span class="line">        <span class="comment">//事件需要在ChannelInboundHandlerAdapter中进行监听处理</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;收到客户端数据：&quot;</span>+msg);</span><br><span class="line">                ctx.channel().writeAndFlush(<span class="string">&quot;已收到！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//没想到吧，这个方法原来是在这个时候用的</span></span><br><span class="line">                <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                    <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                    <span class="keyword">if</span>(event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;好久都没写了，看视频的你真的有认真在跟着敲吗&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经很久很久没有读事件发生了，好寂寞&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们超过一段时间不发送数据时，就会这样：</p>
<p><img src="https://s2.loli.net/2023/03/06/T26DcV39fHULXQ4.png" alt="image-20230306174701901"></p>
<p>通过这种机制，我们就可以直接关掉那些占着茅坑不拉屎的连接。</p>
<h1 id="Netty启动流程源码解读"><a href="#Netty启动流程源码解读" class="headerlink" title="Netty启动流程源码解读"></a>Netty启动流程源码解读</h1><p>首先我们知道，整个服务端是在bind之后启动的，那么我们就从这里开始下手，不多BB直接上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(<span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(inetPort));   <span class="comment">//转换成InetSocketAddress对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进来之后发现是调用的其他绑定方法，继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validate();   <span class="comment">//再次验证一下，看看EventLoopGroup和Channel指定了没</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.initAndRegister();   <span class="comment">//上来第一句初始化然后注册</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看是怎么注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = <span class="built_in">this</span>.channelFactory.newChannel();    <span class="comment">//通过channelFactory创建新的Channel，实际上就是我们在一开始设定的NioServerSocketChannel</span></span><br><span class="line">        <span class="built_in">this</span>.init(channel);    <span class="comment">//接着对创建好的NioServerSocketChannel进行初始化</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.config().group().register(channel); <span class="comment">//将通道注册到bossGroup中的一个EventLoop中</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看是如何对创建好的ServerSocketChannel进行初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    setChannelOptions(channel, <span class="built_in">this</span>.newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, <span class="built_in">this</span>.newAttributesArray());</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在流水线上添加一个Handler，在Handler初始化的时候向EventLoop中提交一个任务，将ServerBootstrapAcceptor添加到流水线上</span></span><br><span class="line">    <span class="comment">//这样我们的ServerSocketChannel在客户端连接时就能Accept了</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> ServerBootstrap.<span class="built_in">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;handler&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                  	<span class="comment">//这里提交一个任务，将ServerBootstrapAcceptor添加到ServerSocketChannel的pipeline中</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下，ServerBootstrapAcceptor怎么处理的，直接看到它的<code>channelRead</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当底层NIO的ServerSocketChannel的Selector有OP_ACCEPT事件到达时，NioEventLoop会接收客户端连接，创建SocketChannel，并触发channelRead回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">  	<span class="comment">//此时msg就是Accept连接创建之后的Channel对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel)msg;</span><br><span class="line">  	<span class="comment">//这里直接将我们之前编写的childHandler添加到新创建的客户端连接的流水线中（是不是感觉突然就通了）</span></span><br><span class="line">    child.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="built_in">this</span>.childHandler&#125;);</span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, <span class="built_in">this</span>.childOptions, ServerBootstrap.logger);</span><br><span class="line">    AbstractBootstrap.setAttributes(child, <span class="built_in">this</span>.childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//直接向workGroup中的一个EventLoop注册新创建好的客户端连接Channel，等待读写事件</span></span><br><span class="line">        <span class="built_in">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">          	<span class="comment">//异步操作完成后，如果没有注册成功，就强制关闭这个Channel</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                	...</span><br></pre></td></tr></table></figure>

<p>所以，实际上就是我们之前讲解的主从Reactor多线程模型，只要前面理解了，这里其实很好推断。</p>
<p>初始化完成之后，我们来看看注册，在之前NIO阶段我们也是需要将Channel注册到对应的Selector才可以开始选择：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.register((ChannelPromise)(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>)));  <span class="comment">//转换成ChannelPromise继续</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);   <span class="comment">//调用Channel的Unsafe接口实现进行注册</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续向下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.register0(promise);    <span class="comment">//这里是继续调用register0方法在进行注册</span></span><br><span class="line">        &#125;</span><br><span class="line">  	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> <span class="built_in">this</span>.neverRegistered;</span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.doRegister();    <span class="comment">//这里开始执行AbstractNioChannel中的doRegister方法进行注册</span></span><br><span class="line">      	AbstractChannel.<span class="built_in">this</span>.registered = <span class="literal">true</span>;</span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="built_in">this</span>.safeSetSuccess(promise);</span><br><span class="line">      	<span class="keyword">if</span> (AbstractChannel.<span class="built_in">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                AbstractChannel.<span class="built_in">this</span>.pipeline.fireChannelActive();   <span class="comment">//这里是关键</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="built_in">this</span>.config().isAutoRead()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到最后一级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">//可以看到在这里终于是真正的进行了注册，javaChannel()得到NIO的Channel对象，然后调用register方法</span></span><br><span class="line">          	<span class="comment">//这里就和我们之前NIO一样了，将Channel注册到Selector中，可以看到Selector也是EventLoop中的</span></span><br><span class="line">          	<span class="comment">//但是注意，这里的ops参数是0，也就是不监听任何事件</span></span><br><span class="line">            <span class="built_in">this</span>.selectionKey = <span class="built_in">this</span>.javaChannel().register(<span class="built_in">this</span>.eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到上一级，在doRegister完成之后，会拿到selectionKey，但是注意这时还没有监听任何事件，我们接着看到下面的fireChannelActive方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(<span class="built_in">this</span>.head);   <span class="comment">//传的是流水线上的默认头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();   <span class="comment">//继续向下</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler)<span class="built_in">this</span>.handler()).channelActive(<span class="built_in">this</span>);   <span class="comment">//依然是调用的头结点的channelActive方法进行处理</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            <span class="built_in">this</span>.invokeExceptionCaught(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;   <span class="comment">//这里是头结点的</span></span><br><span class="line">    ctx.fireChannelActive();    </span><br><span class="line">    <span class="built_in">this</span>.readIfIsAutoRead();   <span class="comment">//继续向下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readIfIsAutoRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DefaultChannelPipeline.<span class="built_in">this</span>.channel.config().isAutoRead()) &#123;</span><br><span class="line">        DefaultChannelPipeline.<span class="built_in">this</span>.channel.read();    <span class="comment">//继续不断向下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.unsafe.beginRead();   <span class="comment">//最后这里会调用beginRead方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">beginRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.doBeginRead();    <span class="comment">//这里就是调用AbstractNioChannel的doBeginRead方法了</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception var2) &#123;</span><br><span class="line">        <span class="built_in">this</span>.invokeLater(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                AbstractChannel.<span class="built_in">this</span>.pipeline.fireExceptionCaught(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.close(<span class="built_in">this</span>.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;    <span class="comment">//先拿到之前注册好的selectionKey</span></span><br><span class="line">    <span class="keyword">if</span> (selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.readPending = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();   <span class="comment">//把监听的操作取出来</span></span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; <span class="built_in">this</span>.readInterestOp) == <span class="number">0</span>) &#123;    <span class="comment">//如果没有监听任何操作</span></span><br><span class="line">            selectionKey.interestOps(interestOps | <span class="built_in">this</span>.readInterestOp);   <span class="comment">//那就把readInterestOp事件进行监听，这里的readInterestOp实际上就是OP_ACCEPT</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，Channel在初始化完成之后也完成了底层的注册，已经可以开始等待事件了。</p>
<p>我们现在回到之前的<code>doBind</code>方法的注册位置，现在注册完成之后，基本上整个主从Reactor结构就已经出来了，我们来看看还要做些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.initAndRegister();  <span class="comment">//目前初始化和注册都已经成功了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();    <span class="comment">//由于是异步操作，我们通过ChannelFuture拿到对应的ServerSocketChannel对象</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;   <span class="comment">//如果说初始化已经完成了</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);   <span class="comment">//直接开始进行进一步的绑定</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//如果还没搞完，那就创Promis继续等待任务完成</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后都会走到<code>doBind0</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(<span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">  	<span class="comment">//最后会向Channel已经注册到的EventLoop中提交一个新的任务</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">              	<span class="comment">//这里才是真正调用Channel底层进行绑定操作</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，服务端的启动流程结束。我们前面还提到了NIO的空轮询问题，这里我们来看看Netty是如何解决的，我们直接定位到NioEventLoop中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于代码太多，这里省略大部分代码</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> var34;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        	...</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="built_in">this</span>.hasTasks()) &#123;</span><br><span class="line">                                strategy = <span class="built_in">this</span>.select(curDeadlineNanos);   <span class="comment">//首先会在这里进行Selector.select()操作，跟NIO是一样的</span></span><br><span class="line">                            &#125;</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">            ++selectCnt;    <span class="comment">//每次唤醒都会让selectCnt自增</span></span><br><span class="line">            <span class="built_in">this</span>.cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">          	...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ranTasks &amp;&amp; strategy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.unexpectedSelectorWakeup(selectCnt)) &#123;   <span class="comment">//这里会进行判断是否出现空轮询BUG</span></span><br><span class="line">           	...</span><br></pre></td></tr></table></figure>

<p>我们来看看是怎么进行判断的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">unexpectedSelectorWakeup</span><span class="params">(<span class="type">int</span> selectCnt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Selector.select() returned prematurely because Thread.currentThread().interrupt() was called. Use NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果selectCnt大于等于SELECTOR_AUTO_REBUILD_THRESHOLD（默认为512）那么会直接重建Selector</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, <span class="built_in">this</span>.selector);</span><br><span class="line">        <span class="built_in">this</span>.rebuildSelector();   <span class="comment">//当前的Selector出现BUG了，得重建一个Selector</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，当每次空轮询发生时会有专门的计数器+1，如果空轮询的次数超过了512次，就认为其触发了空轮询bug，触发bug后，Netty直接重建一个Selector，将原来的Channel重新注册到新的 Selector上，将旧的 Selector关掉，这样就防止了无限循环。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nicegaofeng.top">Better Gaofeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nicegaofeng.top/blog/b2896a54/">https://nicegaofeng.top/blog/b2896a54/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nicegaofeng.top" target="_blank">Better Gaofeng</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/NIO/">NIO</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/1a42ae25/" title="Java多线程补充"><img class="cover" src="https://fp1.fghrsh.net/2020/03/16/cc14c44182a2c667d5d53a13ecd54318.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java多线程补充</div></div></a></div><div class="next-post pull-right"><a href="/blog/305dfbb4/" title="JVM知识点"><img class="cover" src="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM知识点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/f6491cfb/" title="网络编程"><img class="cover" src="https://img0.baidu.com/it/u=1459057103,3186051077&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-04</div><div class="title">网络编程</div></div></a></div><div><a href="/blog/b4c273fd/" title="AQS与ReentrantLock分析"><img class="cover" src="https://fp1.fghrsh.net/2019/11/03/1d7e7ea94ffec6bf7e7c9ce4f2cd9912.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-26</div><div class="title">AQS与ReentrantLock分析</div></div></a></div><div><a href="/blog/af0b9658/" title="CompletableFuture使用"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202209/e4b252312e56bbd6bd61524347497c8f--3279889683.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">CompletableFuture使用</div></div></a></div><div><a href="/blog/550822b9/" title="IOC、AOP、Bean"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202209/b0d5b4cfb7158edc66836c9732a954f9--2732657848.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="title">IOC、AOP、Bean</div></div></a></div><div><a href="/blog/305dfbb4/" title="JVM知识点"><img class="cover" src="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="title">JVM知识点</div></div></a></div><div><a href="/blog/b65740f5/" title="Java多线程中的volatile"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202307/1fc5ecb361188d412771b2f4d5dc8fe8--1140158770.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">Java多线程中的volatile</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/07/cRBHDM7K3xGgPWi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Better Gaofeng</div><div class="author-info__description">一个学习博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XiangGaofeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiangGaofeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:bettergaofeng@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">NIO基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BABuffer"><span class="toc-number">1.1.</span> <span class="toc-text">缓冲区Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">Buffer类及其实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">缓冲区写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IntBuffer-put-int-i"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">IntBuffer put(int i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntBuffer-put-int-i-int-x"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">IntBuffer put(int i, int x)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntBuffer-put-int-src-int-offset-int-length"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">IntBuffer put(int[] src, int offset, int length)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntBuffer-put-IntBuffer-src"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">IntBuffer put(IntBuffer src)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">缓冲区读操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#int-get"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">int get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-int-dst-%E5%92%8Cget-int-dst-int-offset-int-length"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">get(int[] dst)和get(int[] dst, int offset, int length)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.4.</span> <span class="toc-text">缓冲区其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E7%BC%93%E5%86%B2%E5%8C%BA-compact"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">压缩缓冲区 compact()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA-duplicate"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">复制缓冲区 duplicate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%BC%93%E5%86%B2%E5%8C%BA-slice"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">划分缓冲区 slice()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E7%BC%93%E5%86%B2%E5%8C%BA-rewind"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">重置缓冲区 rewind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E7%BC%93%E5%86%B2%E5%8C%BA-rewind"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">清空缓冲区 rewind()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.5.</span> <span class="toc-text">缓冲区比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.1.6.</span> <span class="toc-text">只读缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteBuffer%E5%92%8CCharBuffer"><span class="toc-number">1.1.7.</span> <span class="toc-text">ByteBuffer和CharBuffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93Channel"><span class="toc-number">1.2.</span> <span class="toc-text">通道Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A5%E5%8F%A3%E5%B1%82%E6%AC%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">通道接口层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93FileChannel"><span class="toc-number">1.2.2.</span> <span class="toc-text">文件传输FileChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81FileLock"><span class="toc-number">1.2.3.</span> <span class="toc-text">文件锁FileLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">多路复用网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9EI-x2F-O%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">传统阻塞I&#x2F;O网络通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EI-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">选择器与I&#x2F;O多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">实现Reactor模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.4.</span> <span class="toc-text">不同网络通信之间的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E6%84%8F%E5%9B%BE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">示意图的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">代码的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9EIO-Socket%E5%92%8CSocketChannel"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">传统阻塞IO Socket和SocketChannel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">阻塞IO与多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8BReactor"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">单线程Reactor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F-Handler"><span class="toc-number">1.3.4.2.4.</span> <span class="toc-text">多线程Reactor模式-Handler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F-Reactor"><span class="toc-number">1.3.4.2.5.</span> <span class="toc-text">多线程Reactor模式-Reactor</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">Netty框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">NIO存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">2.2.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteBuf"><span class="toc-number">2.2.1.</span> <span class="toc-text">ByteBuf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.2.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">内核空间与用户空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">零拷贝方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text">使用虚拟内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8mmap-x2F-write%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text">使用mmap&#x2F;write内存映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8sendfile%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.2.3.</span> <span class="toc-text">使用sendfile方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E7%9A%84DirectByteBuf"><span class="toc-number">2.2.2.2.4.</span> <span class="toc-text">Netty的DirectByteBuf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#linux-2-4"><span class="toc-number">2.2.2.2.5.</span> <span class="toc-text">linux 2.4</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">Netty工作模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.4.</span> <span class="toc-text">Channel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ChannelHandler"><span class="toc-number">2.2.4.0.1.</span> <span class="toc-text">ChannelHandler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ChannelPipeline"><span class="toc-number">2.2.4.0.2.</span> <span class="toc-text">ChannelPipeline</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop%E5%92%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.5.</span> <span class="toc-text">EventLoop和任务调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future%E5%92%8CPromise"><span class="toc-number">2.2.6.</span> <span class="toc-text">Future和Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">2.2.7.</span> <span class="toc-text">编码器和解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0HTTP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.8.</span> <span class="toc-text">实现HTTP协议通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AEHandler%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.9.</span> <span class="toc-text">其他内置Handler介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">3.</span> <span class="toc-text">Netty启动流程源码解读</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/f6491cfb/" title="网络编程"><img src="https://img0.baidu.com/it/u=1459057103,3186051077&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程"/></a><div class="content"><a class="title" href="/blog/f6491cfb/" title="网络编程">网络编程</a><time datetime="2023-08-04T07:51:59.000Z" title="发表于 2023-08-04 15:51:59">2023-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/1a42ae25/" title="Java多线程补充"><img src="https://fp1.fghrsh.net/2020/03/16/cc14c44182a2c667d5d53a13ecd54318.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程补充"/></a><div class="content"><a class="title" href="/blog/1a42ae25/" title="Java多线程补充">Java多线程补充</a><time datetime="2023-08-02T04:47:55.000Z" title="发表于 2023-08-02 12:47:55">2023-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/b2896a54/" title="NIO与Netty"><img src="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NIO与Netty"/></a><div class="content"><a class="title" href="/blog/b2896a54/" title="NIO与Netty">NIO与Netty</a><time datetime="2023-08-02T04:26:35.000Z" title="发表于 2023-08-02 12:26:35">2023-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/305dfbb4/" title="JVM知识点"><img src="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM知识点"/></a><div class="content"><a class="title" href="/blog/305dfbb4/" title="JVM知识点">JVM知识点</a><time datetime="2023-08-01T03:00:48.000Z" title="发表于 2023-08-01 11:00:48">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/b4c273fd/" title="AQS与ReentrantLock分析"><img src="https://fp1.fghrsh.net/2019/11/03/1d7e7ea94ffec6bf7e7c9ce4f2cd9912.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS与ReentrantLock分析"/></a><div class="content"><a class="title" href="/blog/b4c273fd/" title="AQS与ReentrantLock分析">AQS与ReentrantLock分析</a><time datetime="2023-07-26T04:02:02.000Z" title="发表于 2023-07-26 12:02:02">2023-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Better Gaofeng</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备2023009336号 </span></a> &nbsp;&nbsp;&nbsp;&nbsp;<img src="https://www.beian.gov.cn/img/new/gongan.png"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42098402000209"><span>鄂公网安备 42098402000209号 </span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>