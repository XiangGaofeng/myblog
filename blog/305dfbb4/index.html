<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM知识点 | Better Gaofeng</title><meta name="author" content="Better Gaofeng"><meta name="copyright" content="Better Gaofeng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM是可运行Java 代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。  Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。  Java 源文件—-&gt;编译器—-&gt;.Class">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM知识点">
<meta property="og:url" content="https://nicegaofeng.top/blog/305dfbb4/index.html">
<meta property="og:site_name" content="Better Gaofeng">
<meta property="og:description" content="JVM是可运行Java 代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。  Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。  Java 源文件—-&gt;编译器—-&gt;.Class">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg">
<meta property="article:published_time" content="2023-08-01T03:00:48.000Z">
<meta property="article:modified_time" content="2023-08-02T06:46:11.027Z">
<meta property="article:author" content="Better Gaofeng">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nicegaofeng.top/blog/305dfbb4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-08-02 14:46:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/06/07/cRBHDM7K3xGgPWi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> GPT</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://gptweb.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTWEB</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academicgpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTACADEMIC</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://gpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTNEXT</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Better Gaofeng"><img class="site-icon" src="https://s2.loli.net/2023/06/30/BjFURc5Nud7k1gE.png"/><span class="site-name">Better Gaofeng</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> GPT</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://gptweb.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTWEB</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://academicgpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTACADEMIC</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://gpt.bettergaofeng.top/"><i class="fa-fw fa-brands fa-space-awesome"></i><span> GPTNEXT</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-01T03:00:48.000Z" title="发表于 2023-08-01 11:00:48">2023-08-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T06:46:11.027Z" title="更新于 2023-08-02 14:46:11">2023-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JVM是可运行Java 代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p> Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。</p>
<ul>
<li>Java 源文件—-&gt;编译器—-&gt;.Class 文件(字节码文件)</li>
<li>.Class 文件(字节码文件)—-&gt;JVM—-&gt;机器码</li>
</ul>
<blockquote>
<p>因此尽管每个平台的解释器都不同(即字节码文件不一样)，但是只要字节码文件符合JVM的规范，就可以编译成能够在该平台上跑的机器码。这就是Java跨平台性的体现。</p>
</blockquote>
<h1 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h1><p>在Java中，只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样就帮助我们节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C&#x2F;C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行。</p>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><img src="https://s2.loli.net/2023/08/01/gh8RSvVfJd9xoGc.jpg" style="zoom: 67%;" />

<img src="https://s2.loli.net/2023/08/01/5oJjiWL2abwSrqC.png" alt="image-20230801111128346" style="zoom:67%;" />

<p>JVM 内存区域主要分为线程私有区域[程序计数器、虚拟机栈、本地方法区]、线程共享区域[JAVA 堆、方法区]、直接内存（不属于运行时数据区域）。</p>
<p>私有数据区域生命周期与线程相同，依赖用户线程的启动&#x2F;结束而创建&#x2F;销毁(在 HotspotVM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存&#x2F;否跟随本地线程的生&#x2F;死对应)。</p>
<h3 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h3><p>而JVM中的程序计数器可以看做是当前线程所执行字节码的行号指示器，而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令。</p>
<p>因为Java的多线程也是依靠时间片轮转算法进行的，因此一个CPU同一时间也只会处理一个线程，当某个线程的时间片消耗完成后，会自动切换到下一个线程继续执行，而当前线程的执行位置会被保存到当前线程的程序计数器中，当下次轮转到此线程时，又继续根据之前的执行位置继续向下执行。</p>
<p>程序计数器因为只需要记录很少的信息，所以只占用很少一部分内存。所以它是不会出现OOM情况的。</p>
<h3 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h3><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个<code>栈结构</code>，*<code>每个方法</code>*被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。&#x3D;&#x3D;每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。&#x3D;&#x3D;栈帧随着方法的调用被创建，随着方法的结束（return或者抛出了在方法内未被捕获的异常）而结束。</p>
<h3 id="本地方法区（线程私有）"><a href="#本地方法区（线程私有）" class="headerlink" title="本地方法区（线程私有）"></a>本地方法区（线程私有）</h3><p>这个其实和虚拟机栈是差不多的，不过它里面是针对与<code>native方法的</code>。</p>
<h3 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h3><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，而此区域的职责就是存放和管理对象和数组(通过new关键字创建的对象都会被放在堆内存)。&#x3D;&#x3D;这也是垃圾回收器进行垃圾收集的最重要的内存区域。&#x3D;&#x3D;</p>
<h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><p>即我们常说的永久代(Permanent Generation)或者元空间(Metaspace)，用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。可以大致分为两个部分，一个是<code>类信息表</code>，一个是<code>运行时常量池</code>。</p>
<p><img src="https://s2.loli.net/2023/08/01/QmKRpcGrFOJkujT.png"></p>
<p>首先类信息表中存放的是当前应用程序加载的所有类信息，包括类的版本、字段、方法、接口等信息，同时会将编译时生成的常量池数据全部存放到运行时常量池中。当然，常量也<code>并不是只能从类信息中获取</code>，在程序运行时，也有可能会有新的常量进入到常量池。运行时常量池 (Runtime Constant Pool) 是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 CIass 文件的每一部分 (自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p>
<p><strong>常量池</strong>：</p>
<p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息.</p>
<p><strong>运行时常量池</strong>：</p>
<p>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址.</p>
<p>这是反编译一个.class文件的结果，可以看到常量池的内容</p>
<img src="https://img-blog.csdnimg.cn/20210208124448238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" style="zoom:50%;" />

<p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p>
<img src="https://img-blog.csdnimg.cn/20210208124525875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" style="zoom:50%;" />

<p>HotSpotVM把GC分代收集扩展至方法区。即使用Java堆的永久代来实现方法区，这样 HotSpot 的垃圾收集器就可以像管理Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对<code>常量池的回收</code>和<code>类型的卸载</code>,因此收益一般很小)。</p>
<blockquote>
<p>在JDK6、JDK7 时，方法区 就是 <code>Permanent Generation</code>（永久代）。JDK8 时，方法区就是 <code>Metaspace</code>（元空间）</p>
<p>明确几点：</p>
<ul>
<li><code>方法区</code> 是 JVM 的规范，所有虚拟机必须遵守。</li>
<li><code>永久代</code>是 HotSpot 虚拟机 基于 JVM 规范对<code>方法区</code>的一个落地实现， 并且只有 HotSpot 才有<code>永久代</code>。</li>
<li><code>永久代</code>是 JDK7及之前， HotSpot 虚拟机 对<code>方法区</code>的一个落地实现。在JDK8被移除。</li>
<li><code>Metaspace</code>(元空间)是 JDK8及之后，废弃了<code>永久代</code>，使用<code>Metaspace</code> ， 这是 HotSpot 虚拟机对<code>方法区</code>的新的落地实现。</li>
<li>元空间与永久代之间最大的区别在于：<em><strong>元空间并不在虚拟机中，而是使用本地内存</strong></em>。</li>
</ul>
</blockquote>
<p>为什么要将<code>永久代</code> 向 <code>元空间</code>转换？</p>
<blockquote>
<p>1）字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。而元空间使用本地内存，其空间比较大，一般的电脑16G内存起步了。</p>
<p>3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
</blockquote>
<img src="https://s2.loli.net/2023/08/01/h3f7n6WNzuPXlwb.png" style="zoom:50%;" />

<h3 id="直接内存（不属于运行时数据区）"><a href="#直接内存（不属于运行时数据区）" class="headerlink" title="直接内存（不属于运行时数据区）"></a>直接内存（不属于运行时数据区）</h3><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C&#x2F;C++调用<code>malloc</code>函数申请的内存，当然得我们自己去释放了。不过虽然是直接内存，不会受到堆内存容量限制，但是依然会受到本机最大内存的限制，所以还是有可能抛出<code>OutOfMemoryError</code>异常。</p>
<p>这里我们需要提到一个堆外内存操作类：<code>Unsafe</code>，就像它的名字一样，虽然Java提供堆外内存的操作类，但是实际上它是不安全的，只有你完全了解底层原理并且能够合理控制堆外内存，才能安全地使用堆外内存。</p>
<p>直接内存实际上就是JVM申请的一块额外的内存空间，但是它并不在受管控的几种内存空间中，当然这些内存依然属于是JVM的，由于JVM提供的堆内存会进行垃圾回收等工作，效率不如直接申请和操作内存来得快，一些比较追求极致性能的框架会用到堆外内存来提升运行速度，如nio框架。</p>
<h1 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h1><p>Java 堆从GC的角度还可以分为: 新生代(Eden 区、From Survivor区和 To Survivor 区)和老年代。在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1</p>
<img src="https://s2.loli.net/2023/08/01/Ao4UYpVEGDPkRK6.png" alt="image-20230801115429834" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2023/08/01/RuSHmFwdD2jtzkc.png"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、Survivor From、Survivor  To 三个区。</p>
<h3 id="Eden-区"><a href="#Eden-区" class="headerlink" title="Eden 区"></a>Eden 区</h3><p>Java 新对象的出生地 (如果新创建的对象占用内存很大，则直接分配到老年代)。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行次垃圾回收。</p>
<h3 id="Survivor-From"><a href="#Survivor-From" class="headerlink" title="Survivor From"></a>Survivor From</h3><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者</p>
<h3 id="Survivor-To"><a href="#Survivor-To" class="headerlink" title="Survivor  To"></a>Survivor  To</h3><p>保留了一次 MinorGC 过程中的幸存者</p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>主要存放应用程序中生命周期长的内存对象。<br>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。&#x3D;&#x3D;当无法找到足够大的连续空间分配给新创建的较大对象时&#x3D;&#x3D;也会提前触发一次 MajorGC 进行垃圾回收腾出空间。<br>MajorGC 采用<code>标记清除算法</code>: 首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MaiorGC 的耗时比较长，因为要扫描再回收。MaiorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM (Out of Memory) 异常。</p>
<h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>指内存的永久保存区域，主要存放 Class 和 Meta (元数据)的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常</p>
<h2 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h2><img src="https://s2.loli.net/2023/08/01/rMBAWGY5gxvLFT7.png" alt="image-20230801122150286" style="zoom:50%;" />

<ol>
<li>新创建的对象在一开始都会进入到新生代的Eden区,如果是大对象(超出Survivor区的容量)会被直接丢进老年代(&#x3D;&#x3D;空间分配担保&#x3D;&#x3D;)，当Eden满了，Minor GC 一次，在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象。然后将没有被回收的对象放到To区</li>
<li>交换From和To的位置。现在Eden和To是空的，然后From是上一次没有被回收的对象</li>
<li>Eden又进来新对象了，又要满了</li>
<li>Minor GC 一次，因为From区也有对象，所以也要扫描</li>
<li>Eden和From存活的对象都进入To区。</li>
<li>交换From和To的位置。现在Eden和To是空的，然后From是上一次没有被回收的对象。相当于又循环进入到了第2步了</li>
</ol>
<blockquote>
<p>在一次GC后，新生代Eden区仍然存在大量的对象（因为GC之后存活对象会进入到一个Survivor区，但是很明显这时已经超出Survivor区的容量了，肯定是装不下的）那么现在该怎么办？</p>
<p>这时就需要用到<code>空间分配担保机制</code>了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保（当然老年代也得装得下才行）在现实生活中，贷款会指定担保人，就是当借款人还不起钱的时候由担保人来还钱。</p>
<p>当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p>
<p>那既然新生代装不下就丢给老年代，那么要是老年代也装不下新生代的数据呢？这时，老年代肯定担保人是当不成了，那么这样的话，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出OOM错误，摆烂。</p>
</blockquote>
<blockquote>
<ul>
<li>每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，那么会直接进入到老年代（通过判断晋升到老年代的对象平均大小是否小于老年代剩余空间，如果小于，赌一手，直接进去，如果大于，sorry ，赌狗不得house，我觉得我进不去，申请一下Full GC，要是还是装不下，直接抛出OOM）</li>
<li>如果Eden和From存活的对象放不进To区，直接请进老年代</li>
</ul>
</blockquote>
<blockquote>
<p>而垃圾收集也分为：</p>
<ul>
<li>Minor GC - 次要垃圾回收，主要进行<code>新生代</code>区域的垃圾收集。<ul>
<li>触发条件：新生代的Eden区容量已满时。</li>
</ul>
</li>
<li>Major GC - 主要垃圾回收，主要进行<code>老年代</code>的垃圾收集。</li>
<li>Full GC - 完全垃圾回收，对<code>整个Java堆内存和方法区</code>进行垃圾回收。<ul>
<li>触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间(我不敢赌这一次能放进去)</li>
<li>触发条件2：Minor GC后存活的对象超过了老年代剩余空间（真放不下了）</li>
<li>触发条件3：永久代内存不足（JDK8之前）</li>
<li>触发条件4：手动调用<code>System.gc()</code>方法(只是通知，做不做看JVM心情)</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><img src="https://s2.loli.net/2023/08/01/LiUSkmRxHeMoJOa.png" alt="image-20230801123919077"  />

<h2 id="怎么样的才算是垃圾"><a href="#怎么样的才算是垃圾" class="headerlink" title="怎么样的才算是垃圾"></a>怎么样的才算是垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>实际上，我们会发现，只要一个对象还有使用价值，我们就会通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p>
<ul>
<li>每个对象都包含一个 <strong>引用计数器</strong>，用于存放引用计数（其实就是存放被引用的次数）</li>
<li>每当有一个地方引用此对象时，引用计数<code>+1</code></li>
<li>当引用失效（ 比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li>
<li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li>
</ul>
<p>但是这样存在一个问题，如果两个对象相互引用，按照引用计数算法，那么当出现以上情况时，虽然我们无法在得到此对象的引用了，并且此对象我们也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，但是实际上此对象已经没有任何用途了。所以引用计数法并不是最好的解决方案。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>目前比较主流的编程语言（包括Java），一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p>
<p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p>
<ul>
<li>位于虚拟机栈的栈帧中的本地变量表中所引用到的对象（其实就是我们方法中的局部变量）同样也包括本地方法栈中JNI(即一般说的Native方法)引用的对象。</li>
<li>类的静态成员变量引用的对象。</li>
<li>方法区中，常量池里面引用的对象，比如<code>String</code>类型对象。</li>
<li>被添加了锁的对象（比如synchronized关键字）</li>
<li>虚拟机内部需要用到的对象。</li>
</ul>
<p>&#x3D;&#x3D;如果某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的。&#x3D;&#x3D;</p>
<h2 id="怎么清理标记出来的垃圾"><a href="#怎么清理标记出来的垃圾" class="headerlink" title="怎么清理标记出来的垃圾"></a>怎么清理标记出来的垃圾</h2><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>首先标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p>
<p><img src="https://s2.loli.net/2023/08/01/v5ElHS7di6WmfKb.png"></p>
<p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，<code>碎片化会导致连续内存空间利用率降低</code></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>标记复制算法，实际上就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题。</p>
<p><img src="https://s2.loli.net/2023/08/01/aN26W98UObV4iYe.png"></p>
<p>这种算法就非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，而我们之前所说的新生代Survivor区其实就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的。</p>
<p>但是缺点很明显，你需要双倍的内存空间</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。我们知道，一般长期都回收不到的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p>
<p>那么我们能否这样，在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p>
<p><img src="https://s2.loli.net/2023/08/01/9A56OtmEgVex7Jr.png"></p>
<p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点也是显而易见的，它的效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿（被称为“Stop The World”，STW）。</p>
<p>所以，我们可以将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法其实是没有多大问题的，当内存空间凌乱到一定程度后，我们可以进行一次标记整理算法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>标记-清除算法，简单，但是会出现大量标记，而且内存碎片多</li>
<li>标记-复制算法，效率高，没有内存碎片，但是需要双倍的内存空间。&#x3D;&#x3D;适用于新生代&#x3D;&#x3D;</li>
<li>标记-整理算法，比标记-复制算法简单，但是效率比前两个更慢，而且会出现STW，&#x3D;&#x3D;适合于老年代，因为老年代回收的次数比较少&#x3D;&#x3D;</li>
</ul>
<h1 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h1><p>对象存活判定和垃圾回收算法已经说明了，接着我们就要看看具体有哪些垃圾回收器的实现了。我们可以自由地为新生代和老年代选择更适合它们的收集器。</p>
<p>先来几个概念：</p>
<ul>
<li><code>并行收集</code>：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li>
<li><code>并发收集</code>：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个 CPU 上</li>
<li><code>吞吐量</code>：即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行 100 分钟，垃圾收集器花掉 1 分钟，那么吞吐量就是 99% 。</li>
<li><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象<br>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</li>
</ul>
<h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><p>适合单线程环境，因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</p>
<p><img src="https://s2.loli.net/2023/08/01/1aQNjS3lnROekt4.png"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这款垃圾收集器也是元老级别的收集器了，在JDK1.3.1之前，是虚拟机新生代区域收集器的唯一选择。这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是<code>标记复制算法</code>，老年代采用的是<code>标记整理算法</code>。</p>
<p><img src="https://s2.loli.net/2023/08/01/xDh6YgqXFHr5yi9.png"></p>
<p>可以看到，当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作(STW)，就相当于你打一把LOL 40分钟，中途每隔1分钟网络就卡5秒钟，可能这时你正在打团，结果你被物理控制直接在那里站了5秒钟，这确实让人难以接受。</p>
<p>虽然缺点很明显，但是优势也是显而易见的：</p>
<ol>
<li>设计简单而高效。</li>
<li>在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li>
</ol>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>Serial收集器的多线程版本，它能够支持多线程垃圾收集,同样的有STW问题的产生。</p>
<p><img src="https://s2.loli.net/2023/08/01/2AQ1Ys3wyi4W9Ot.png"></p>
<h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短</li>
</ul>
<h3 id="Parallel-Scavenge-x2F-Parallel-Old收集器"><a href="#Parallel-Scavenge-x2F-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>Parallel Scavenge同样是一款面向新生代的垃圾收集器，同样采用标记复制算法实现，在JDK6时也推出了其老年代收集器Parallel Old，采用标记整理算法实现：</p>
<img src="https://s2.loli.net/2023/08/01/oMraqViU2hGTOAJ.png" style="zoom:50%;" />

<p>与ParNew收集器不同的是，Parallel Scavenge会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间该收集器的目标是达到一个可控制的吞吐量。即GC自适应调节策略（与 ParNew 收集器最重要的一个区别），这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案。</p>
<p>GC自适应调节策略：</p>
<p>Parallel Scavenge 收集器可设置 -XX:+UseAdptiveSizePolicy 参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC 的自适应调节策略。</p>
<p>Parallel Scavenge 收集器使用两个参数控制吞吐量：</p>
<p>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）<br>         XX:GCTimeRatio&#x3D;rario 直接设置吞吐量的大小</p>
<p>Parallel Scavenge 收集器：</p>
<p><img src="https://s2.loli.net/2023/08/01/rh8IFVLQsPOK5Yg.png" alt="image-20230801132540830"></p>
<p>Parallel Old收集器：</p>
<p><img src="https://s2.loli.net/2023/08/01/wMdsl4F1EOmLBWC.png" alt="image-20230801132620475"></p>
<p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。是一种以获取<code>最短回收停顿时间</code>为目标的<strong>老年代收集器</strong></p>
<p><strong>特点</strong>：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片<br>         <strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如 web 程序、b&#x2F;s 服务</p>
<p>它主要采用标记清除算法：</p>
<p><img src="https://s2.loli.net/2023/08/01/Sg5z82wUimfNXlT.png"></p>
<p>它的垃圾回收分为4个阶段：</p>
<ul>
<li>初始标记（需要暂停用户线程，仍存在STW问题）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，找出存活对象且用户线程，这个过程<code>耗时较长但是不需要停顿用户线程</code>，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（需要暂停用户线程）：由于并发标记阶段可能某些用户线程会导致标记产生变更，因此这里需要再次暂停所有线程进行并行标记，这个时间会比初始标记时间长一丢丢。</li>
<li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行。清除的过程中，可能仍然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器(serial 收集器的老年代版本)，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li>
</ul>
<p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢。</p>
<p>不过，如果你希望的是最低的GC停顿时间，这款垃圾收集器无疑是最佳选择，不过自从G1收集器问世之后，CMS收集器不再推荐使用了。</p>
<h2 id="G1-Garbage-First-收集器"><a href="#G1-Garbage-First-收集器" class="headerlink" title="G1(Garbage First) 收集器"></a>G1(Garbage First) 收集器</h2><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li>
<li>整体上是标记-整理算法，两个区域之间是复制算法</li>
</ul>
<p>在JDK9时，取代了JDK8默认的 Parallel Scavenge + Parallel Old 的回收方案。</p>
<p>我们知道，我们的垃圾回收分为<code>Minor GC</code>、<code>Major GC</code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器巧妙地绕过了这些约定，它将整个Java堆划分成<code>2048</code>个大小相同的独立<code>Region</code>块，每个<code>Region块</code>的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变。</p>
<p>那么分出这些<code>Region</code>有什么意义呢？每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。</p>
<p><img src="https://s2.loli.net/2023/08/01/ClzHBFRDawiSGjT.png"></p>
<p>它的回收过程与CMS大体类似：</p>
<p><img src="https://s2.loli.net/2023/08/01/AZo7yWhO2YXB53J.png"></p>
<p>分为以下四个步骤：</p>
<ul>
<li>初始标记（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</li>
<li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本<code>进行排序</code>，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</li>
</ul>
<p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1收集器两个最突出的改进是:</p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收.</li>
</ol>
<p>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p>
<h1 id="强软弱虚—-四大金刚"><a href="#强软弱虚—-四大金刚" class="headerlink" title="强软弱虚—-四大金刚"></a>强软弱虚—-四大金刚</h1><ul>
<li>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，就算JVM挂了、出OOM你也别回收了。</li>
<li>软引用。内存够，你别管我，内存不够了，你回收我吧</li>
<li>弱引用，你只要GC，我就滚了（localthreadMap的key就是弱引用）</li>
<li>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。我也不知道我什么时候就没了</li>
</ul>
<h1 id="GC-分代收集算法-VS-分区收集算法"><a href="#GC-分代收集算法-VS-分区收集算法" class="headerlink" title="GC 分代收集算法 VS 分区收集算法"></a>GC 分代收集算法 VS 分区收集算法</h1><ul>
<li>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法,这种算法会根据对象存活周期的不同将内存划分为几块,如JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法</li>
<li>分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收.这样做的好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而不是整个堆)，从而减少一次 GC 所产生的停顿。</li>
</ul>
<h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><p>JVM 类加载机制分为五个部分: 加载，验证，准备，解析，初始化。</p>
<p><img src="https://s2.loli.net/2023/08/01/XHUpcuPzdxt2kG4.png" alt="image-20230801134012733"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取(比如从jar 包和 war 包中读取)，也可以在运行时计算生成(动态代理)也可以由其它文件生成(比如将JSP 文件转换成对应的 Class 类)。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 10，将 赋值为 10的 put static 指令是程序被编译后，存放于类构造器<client>方法之中但是注意如果声明为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>在编译阶段会为v生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将v赋值为10.</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是Java虚拟机对类或接口的符号引用进行处理的过程，其中符号引用被替换为直接引用。符号引用是一种编译时的引用，它通过符号来描述所引用的目标，比如类名、方法名、字段名等。而直接引用是指直接指向内存中的对象、方法或字段的引用。</p>
<p>在解析阶段，虚拟机会根据符号引用的信息，定位并替换为对应的直接引用，以便在运行时能够直接访问到目标对象、方法或字段。符号引用就是 class 文件中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT Class info</span><br><span class="line">CONSTANT Field info</span><br><span class="line">CONSTANT Method info</span><br></pre></td></tr></table></figure>

<blockquote>
<p>符号引用:符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中.</p>
<p>直接引用: 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
</blockquote>
<p>举个例子来说明，假设有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，<code>System.out.println(message)</code>中的<code>System.out</code>和<code>println</code>都是符号引用，它们并不直接指向内存中的对象或方法。在解析阶段，虚拟机会根据这些符号引用的信息，找到对应的直接引用。例如，<code>System.out</code>会被解析为<code>java.lang.System</code>类中的静态字段<code>out</code>，<code>println</code>会被解析为<code>java.io.PrintStream</code>类中的方法<code>println</code>。</p>
<p>通过解析阶段，虚拟机将符号引用替换为直接引用，使得在运行时能够直接访问到目标对象或方法，从而执行相应的操作。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>JVM的类加载机制中的初始化阶段是类加载过程的最后一步，用于对类进行初始化操作。在初始化阶段，JVM会执行类的初始化器 <code>&lt;clinit&gt;()</code> 方法，该方法是由编译器自动生成的，包含了类的静态变量赋值和静态代码块的初始化代码。</p>
<p>类的初始化在以下情况下会被触发：</p>
<ol>
<li><p>创建类的实例：当使用 <code>new</code> 关键字创建类的实例时，如果该类还没有被初始化，则会触发初始化过程。</p>
</li>
<li><p>访问类的静态变量或静态方法：当访问一个类的静态变量或调用静态方法时，如果该类还没有被初始化，则会触发初始化过程。</p>
</li>
<li><p>反射调用：当通过反射机制对类进行操作时，如果该类还没有被初始化，则会触发初始化过程。</p>
</li>
<li><p>主类启动：当启动 Java 程序的主类时，JVM会先初始化该主类。</p>
</li>
</ol>
<p>需要注意的是，类的初始化是按需进行的，即只有在<code>需要使用类的时候才会触发初始化</code>。JVM保证在多线程环境下，<code>一个类只会被初始化一次</code>，避免了多个线程同时触发类初始化的问题。</p>
<p>在类的初始化阶段，可以进行一些静态变量的赋值、静态代码块的执行，以及执行其他需要在类加载时完成的初始化操作。初始化阶段是类加载过程中的重要一步，它为类的使用提供了必要的准备工作，确保类在使用前处于可运行的状态。</p>
<h2 id="类构造器clinit"><a href="#类构造器clinit" class="headerlink" title="类构造器clinit"></a>类构造器clinit</h2><blockquote>
<p><code>&lt;clinit&gt;</code> 是一个特殊的类初始化器方法，它在类加载过程的初始化阶段被执行。</p>
<p><code>&lt;clinit&gt;</code> 方法是由编译器自动生成的，它包含了类的静态变量赋值和静态代码块的初始化代码。这个方法的名称 <code>&lt;clinit&gt;</code> 是由 “class initialization” 的缩写而来。当一个类被初始化时，JVM会自动执行 <code>&lt;clinit&gt;()</code> 方法，它的执行过程由编译器生成的字节码指令来实现。该方法会按照静态变量的声明顺序依次执行静态变量的赋值操作，然后执行静态代码块中的初始化代码。<code>&lt;clinit&gt;</code> 方法的执行是在单线程环境下进行的，JVM会保证在多线程环境中只有一个线程执行该方法，从而避免了多个线程同时执行类初始化的问题。</p>
<p>需要注意的是，<code>&lt;clinit&gt;</code> 方法是隐式调用的，我们无法在代码中直接调用它。它的主要作用是完成类的静态成员的初始化工作，确保类在使用前处于可运行的状态。量虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中&#x3D;&#x3D;没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>方法。&#x3D;&#x3D;</p>
</blockquote>
<p>注意以下几种情况不会执行类初始化</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义<code>该对象数组</code>，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类</li>
<li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会发初始化动作。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>JVM的类加载器（Class Loader）是负责加载Java类文件的组件。它将类的字节码加载到JVM中，并将其转换为可以在运行时使用的Java类。</p>
<p>JVM的类加载器有以下几种类型：</p>
<ol>
<li><p>启动类加载器（Bootstrap Class Loader）：它是JVM的一部分，负责加载Java的核心类库，如<code>java.lang</code>包中的类。启动类加载器是由JVM实现的，通常用本地代码实现，不继承自<code>java.lang.ClassLoader</code>。负责加载JAVA_HOME&#x2F;lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可(按文件名识别，如 rt.jar) 的类</p>
</li>
<li><p>扩展类加载器（Extension Class Loader）：它是由<code>sun.misc.Launcher$ExtClassLoader</code>实现的，负责加载Java的扩展类库，如<code>java.ext.dirs</code>系统属性指定的目录中的类。负责加载JAVA_HOME&#x2F;lib&#x2F;ext 目录中的.</p>
</li>
<li><p>应用程序类加载器（Application Class Loader）：也称为系统类加载器（System Class Loader），它是由<code>sun.misc.Launcher$AppClassLoader</code>实现的，负责加载应用程序的类。它是默认的类加载器，也是大多数Java应用程序中使用的类加载器。</p>
</li>
</ol>
<p>除了上述三种主要的类加载器之外，JVM还支持自定义类加载器，开发人员可以通过继承<code>java.lang.ClassLoader</code>类来实现自己的类加载器。自定义类加载器可以用于加载非标准的类文件，实现类加载的特定需求，例如从网络或数据库中加载类等。</p>
<p>类加载器采用了<code>双亲委派模型</code>（Parent Delegation Model），即&#x3D;&#x3D;在类加载过程中，一个类加载器会首先将类加载请求委派给其父类加载器，只有在父类加载器无法加载该类时，才由自身来加载&#x3D;&#x3D;。这种模型可以确保类的加载是层次性的、有序的，并避免了类的重复加载。</p>
<p>类加载器在JVM中起着重要的作用，它使得Java的动态扩展和加载成为可能，为Java的灵活性和可扩展性提供了基础。</p>
<p><img src="https://s2.loli.net/2023/08/01/Is1jXyPMY3oCQEv.png" alt="image-20230801191753791"></p>
<p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p>
<p>另外，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个。JVM使用的双亲委派就能解决这个问题，每个类只加载它能加载的，自顶向下，上面的能加载，下面的就不加载了。</p>
<img src="https://s2.loli.net/2023/08/01/4LbTmcBjFKdh9G8.png" style="zoom:67%;" />

<blockquote>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nicegaofeng.top">Better Gaofeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nicegaofeng.top/blog/305dfbb4/">https://nicegaofeng.top/blog/305dfbb4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nicegaofeng.top" target="_blank">Better Gaofeng</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/b2896a54/" title="NIO与Netty"><img class="cover" src="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NIO与Netty</div></div></a></div><div class="next-post pull-right"><a href="/blog/b4c273fd/" title="AQS与ReentrantLock分析"><img class="cover" src="https://fp1.fghrsh.net/2019/11/03/1d7e7ea94ffec6bf7e7c9ce4f2cd9912.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AQS与ReentrantLock分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/b4c273fd/" title="AQS与ReentrantLock分析"><img class="cover" src="https://fp1.fghrsh.net/2019/11/03/1d7e7ea94ffec6bf7e7c9ce4f2cd9912.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-26</div><div class="title">AQS与ReentrantLock分析</div></div></a></div><div><a href="/blog/550822b9/" title="IOC、AOP、Bean"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202209/b0d5b4cfb7158edc66836c9732a954f9--2732657848.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-22</div><div class="title">IOC、AOP、Bean</div></div></a></div><div><a href="/blog/af0b9658/" title="CompletableFuture使用"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202209/e4b252312e56bbd6bd61524347497c8f--3279889683.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">CompletableFuture使用</div></div></a></div><div><a href="/blog/8b9d7b34/" title="Java 锁--整理于尚硅谷JUC课程"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202306/65dd83f0f0600aa172c67b4db89b5c8f--2032768543.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">Java 锁--整理于尚硅谷JUC课程</div></div></a></div><div><a href="/blog/b65740f5/" title="Java多线程中的volatile"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202307/1fc5ecb361188d412771b2f4d5dc8fe8--1140158770.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">Java多线程中的volatile</div></div></a></div><div><a href="/blog/bd20a05b/" title="Java锁的状态及锁升级"><img class="cover" src="http://cdn-hw-static.shanhutech.cn/bizhi/staticwp/202306/371e3e98fb0b1740f1ea00f68ded583b--409864287.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-25</div><div class="title">Java锁的状态及锁升级</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/06/07/cRBHDM7K3xGgPWi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Better Gaofeng</div><div class="author-info__description">一个学习博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XiangGaofeng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiangGaofeng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:bettergaofeng@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">JVM内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">内存区域划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序计数器(线程私有)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟机栈（线程私有）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">本地方法区（线程私有）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">堆（线程共享）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">方法区（线程共享）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88%E4%B8%8D%E5%B1%9E%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">直接内存（不属于运行时数据区）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">JVM运行时内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">2.1.</span> <span class="toc-text">新生代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eden-%E5%8C%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">Eden 区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Survivor-From"><span class="toc-number">2.1.2.</span> <span class="toc-text">Survivor From</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Survivor-To"><span class="toc-number">2.1.3.</span> <span class="toc-text">Survivor  To</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">2.2.</span> <span class="toc-text">老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-number">2.3.</span> <span class="toc-text">永久代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">分代收集机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E6%89%8D%E7%AE%97%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-number">3.1.</span> <span class="toc-text">怎么样的才算是垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B8%85%E7%90%86%E6%A0%87%E8%AE%B0%E5%87%BA%E6%9D%A5%E7%9A%84%E5%9E%83%E5%9C%BE"><span class="toc-number">3.2.</span> <span class="toc-text">怎么清理标记出来的垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">垃圾收集器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">串行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">ParNew 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">4.2.</span> <span class="toc-text">吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-x2F-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">Parallel Scavenge&#x2F;Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">CMS 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1-Garbage-First-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">G1(Garbage First) 收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E2%80%94-%E5%9B%9B%E5%A4%A7%E9%87%91%E5%88%9A"><span class="toc-number">5.</span> <span class="toc-text">强软弱虚—-四大金刚</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-VS-%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">GC 分代收集算法 VS 分区收集算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">JVM类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">7.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">7.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8clinit"><span class="toc-number">7.6.</span> <span class="toc-text">类构造器clinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">类加载器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/f6491cfb/" title="网络编程"><img src="https://img0.baidu.com/it/u=1459057103,3186051077&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程"/></a><div class="content"><a class="title" href="/blog/f6491cfb/" title="网络编程">网络编程</a><time datetime="2023-08-04T07:51:59.000Z" title="发表于 2023-08-04 15:51:59">2023-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/1a42ae25/" title="Java多线程补充"><img src="https://fp1.fghrsh.net/2020/03/16/cc14c44182a2c667d5d53a13ecd54318.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java多线程补充"/></a><div class="content"><a class="title" href="/blog/1a42ae25/" title="Java多线程补充">Java多线程补充</a><time datetime="2023-08-02T04:47:55.000Z" title="发表于 2023-08-02 12:47:55">2023-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/b2896a54/" title="NIO与Netty"><img src="https://fp1.fghrsh.net/2019/10/03/69354ef70ad550d7e98d6e0596e11ef2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NIO与Netty"/></a><div class="content"><a class="title" href="/blog/b2896a54/" title="NIO与Netty">NIO与Netty</a><time datetime="2023-08-02T04:26:35.000Z" title="发表于 2023-08-02 12:26:35">2023-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/305dfbb4/" title="JVM知识点"><img src="https://fp1.fghrsh.net/2019/11/01/3e77e955abc179d4584573a956fa2a28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM知识点"/></a><div class="content"><a class="title" href="/blog/305dfbb4/" title="JVM知识点">JVM知识点</a><time datetime="2023-08-01T03:00:48.000Z" title="发表于 2023-08-01 11:00:48">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/b4c273fd/" title="AQS与ReentrantLock分析"><img src="https://fp1.fghrsh.net/2019/11/03/1d7e7ea94ffec6bf7e7c9ce4f2cd9912.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AQS与ReentrantLock分析"/></a><div class="content"><a class="title" href="/blog/b4c273fd/" title="AQS与ReentrantLock分析">AQS与ReentrantLock分析</a><time datetime="2023-07-26T04:02:02.000Z" title="发表于 2023-07-26 12:02:02">2023-07-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Better Gaofeng</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备2023009336号 </span></a> &nbsp;&nbsp;&nbsp;&nbsp;<img src="https://www.beian.gov.cn/img/new/gongan.png"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42098402000209"><span>鄂公网安备 42098402000209号 </span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>